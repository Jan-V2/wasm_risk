#![feature(prelude_import)]
#![allow(dead_code)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
mod element_getters {
    #![allow(dead_code)]
    use wasm_bindgen::prelude::*;
    use web_sys::{
        CanvasRenderingContext2d, Element, HtmlButtonElement, HtmlCanvasElement,
        HtmlInputElement, HtmlLabelElement,
    };
    pub fn get_html_label_by_id(id: &str) -> HtmlLabelElement {
        return get_element_by_id(id)
            .dyn_into::<HtmlLabelElement>()
            .map_err(|_| ())
            .unwrap();
    }
    pub fn get_html_input_by_id(id: &str) -> HtmlInputElement {
        return get_element_by_id(id)
            .dyn_into::<HtmlInputElement>()
            .map_err(|_| ())
            .unwrap();
    }
    pub fn get_button_by_id(id: &str) -> HtmlButtonElement {
        return get_element_by_id(id)
            .dyn_into::<HtmlButtonElement>()
            .map_err(|_| ())
            .unwrap();
    }
    pub fn get_element_by_id(id: &str) -> Element {
        let document = web_sys::window().unwrap().document().unwrap();
        return document.get_element_by_id(id).unwrap();
    }
    pub fn set_info_field(string: String) {
        let elem = get_element_by_id("text_out")
            .dyn_into::<HtmlLabelElement>()
            .map_err(|_| ())
            .unwrap();
        elem.set_inner_text(
            &{
                let res = ::alloc::fmt::format(format_args!("{0}", string));
                res
            },
        );
    }
    pub fn get_canvas() -> HtmlCanvasElement {
        let canvas = get_element_by_id("canvas");
        return canvas.dyn_into::<HtmlCanvasElement>().map_err(|_| ()).unwrap();
    }
    pub fn get_drawing_context(canvas: &HtmlCanvasElement) -> CanvasRenderingContext2d {
        return canvas
            .get_context("2d")
            .unwrap()
            .unwrap()
            .dyn_into::<web_sys::CanvasRenderingContext2d>()
            .unwrap();
    }
}
mod canvas {
    use std::cell::RefCell;
    use std::rc::Rc;
    use wasm_bindgen::prelude::*;
    use web_sys::{
        CanvasRenderingContext2d, HtmlCanvasElement, HtmlImageElement, MouseEvent,
    };
    use crate::element_getters::*;
    use crate::game::{Game, ProvLookupTable};
    use crate::model::{Coord, Model, Province};
    extern crate queues;
    pub fn get_map_lookup_data(max_div: u32) -> ProvLookupTable {
        let canvas = get_canvas();
        let context = get_drawing_context(&canvas);
        draw_board_raw(&canvas, &context);
        let img_data = context
            .get_image_data(0f64, 0f64, canvas.width() as f64, canvas.height() as f64)
            .unwrap()
            .data();
        let mut ret: Vec<[u8; 3]> = Vec::new();
        for i in (0..img_data.len()).step_by(4) {
            ret.push([img_data[i], img_data[i + 1], img_data[i + 2]]);
        }
        return ProvLookupTable {
            pixels: ret,
            width: canvas.width(),
            max_div,
        };
    }
    pub fn ui_init_canvas(game_model: Rc<RefCell<Game>>) {
        let canvas = get_canvas();
        let game_model_clone = game_model.clone();
        let canvas_xy_mouseover_handeler = Closure::<
            dyn FnMut(_),
        >::new(move |event: MouseEvent| {
            let label = get_html_label_by_id("xy_coord_label");
            label
                .set_inner_text(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "canvas coord x:{0} y:{1}",
                                event.offset_x(),
                                event.offset_y(),
                            ),
                        );
                        res
                    },
                );
            let mut text: Option<String> = None;
            let game_borrow = game_model_clone.as_ref().try_borrow();
            if game_borrow.is_ok() {
                let game_unwrap = game_borrow.unwrap();
                text = game_unwrap
                    .get_prov_mouseover_string(
                        &Coord {
                            x: event.offset_x(),
                            y: event.offset_y(),
                        },
                    );
                game_unwrap.draw_board();
            }
            if text.is_some() {
                let canvas = get_canvas();
                let ct = get_drawing_context(&canvas);
                let point_size = 13f64;
                let font_str = {
                    let res = ::alloc::fmt::format(
                        format_args!("bold {0}px serif", (point_size) as i32),
                    );
                    res
                };
                ct.set_fill_style(&JsValue::from_str("black"));
                ct.set_font(&font_str);
                ct.set_text_align("right");
                let _ = ct
                    .fill_text(
                        text.unwrap().as_str(),
                        event.offset_x() as f64,
                        event.offset_y() as f64,
                    );
            }
        });
        let _ = canvas
            .add_event_listener_with_callback(
                "mousemove",
                canvas_xy_mouseover_handeler.as_ref().unchecked_ref(),
            );
        canvas_xy_mouseover_handeler.forget();
        let canvas_click_handler = Closure::<
            dyn FnMut(_),
        >::new(move |_event: MouseEvent| {
            let _canvas = get_canvas();
            let clicked_coord = [
                _event.x() - _canvas.offset_left(),
                _event.y() - _canvas.offset_top(),
            ];
            let ret_coord = Coord {
                x: clicked_coord[0],
                y: clicked_coord[1],
            };
            game_model.as_ref().borrow_mut().handle_canvas_click(ret_coord);
        });
        let _ = canvas
            .add_event_listener_with_callback(
                "click",
                canvas_click_handler.as_ref().unchecked_ref(),
            );
        canvas_click_handler.forget();
    }
    pub fn redraw_board_state(model: &Model, scale: f64, draw_flags: bool) {
        draw_board();
        if draw_flags {
            draw_all_flags(&model, scale);
            draw_all_army_count(&model.provinces, scale);
        }
    }
    fn draw_all_flags(model: &Model, scale: f64) {
        let canvas = get_canvas();
        let ct = get_drawing_context(&canvas);
        for prov in &model.provinces {
            if prov.owner_id != 100 {
                draw_flag_raw(
                    &prov,
                    &model.players[prov.owner_id as usize].color,
                    scale,
                    &ct,
                );
            } else {
                draw_flag_raw(&prov, &"blue".to_string(), scale, &ct);
            }
        }
    }
    fn draw_flag_raw(
        prov: &Province,
        color: &String,
        scale: f64,
        ct: &CanvasRenderingContext2d,
    ) {
        let bot_w = 30f64 * scale;
        let staff_height = 35f64 * scale;
        let flag_height = 20f64 * scale;
        let flag_width = 20f64 * scale;
        let half_bot: f64 = bot_w / 2f64;
        let origin = [prov.location.x as f64, prov.location.y as f64];
        ct.set_line_width(2f64);
        ct.set_fill_style(&JsValue::from_str(color));
        ct.begin_path();
        ct.move_to(origin[0] - half_bot, origin[1]);
        ct.line_to(origin[0] + half_bot, origin[1]);
        ct.move_to(origin[0], origin[1]);
        let top_staff = [origin[0], origin[1] - staff_height];
        ct.line_to(top_staff[0], top_staff[1]);
        ct.line_to(top_staff[0] + flag_width, top_staff[1] + flag_height / 2f64);
        ct.line_to(top_staff[0], top_staff[1] + flag_height);
        ct.stroke();
        ct.fill();
    }
    fn draw_all_army_count(provs: &Vec<Province>, scale: f64) {
        let canvas = get_canvas();
        let ct = get_drawing_context(&canvas);
        let padding = 3f64;
        let point_size = 22f64;
        let font_str = {
            let res = ::alloc::fmt::format(
                format_args!("{0}px serif", (point_size * scale) as i32),
            );
            res
        };
        ct.set_fill_style(&JsValue::from_str("black"));
        ct.set_font(&font_str);
        ct.set_text_align("right");
        let draw_count = |prov: &Province| {
            let origin = [prov.location.x as f64, prov.location.y as f64];
            let _ = ct
                .fill_text(
                    prov.army_count.to_string().as_str(),
                    origin[0] - padding,
                    origin[1] - padding,
                );
        };
        for prov in provs {
            draw_count(&prov);
        }
    }
    pub fn draw_board() {
        let canvas = get_canvas();
        draw_board_raw(&canvas, &get_drawing_context(&canvas));
    }
    fn draw_board_raw(canvas: &HtmlCanvasElement, context: &CanvasRenderingContext2d) {
        context.rect(0f64, 0f64, canvas.width() as f64, canvas.height() as f64);
        context.set_fill_style(&JsValue::from_str("LightCyan"));
        context.fill();
        let image = get_element_by_id("board_2")
            .dyn_into::<HtmlImageElement>()
            .map_err(|_| ())
            .unwrap();
        let _ = context
            .draw_image_with_html_image_element_and_dw_and_dh(
                &image,
                0f64,
                0f64,
                canvas.width() as f64,
                canvas.height() as f64,
            );
    }
}
mod model {
    use std::fmt;
    use std::fmt::Formatter;
    use queues::{IsQueue, Queue};
    use serde::{Deserialize, Serialize};
    use crate::data_include::{get_map_data, get_navtree_data};
    pub struct Model {
        pub provinces: Vec<Province>,
        pub nav_tree: NavTree,
        pub players: Vec<Player>,
        pub rules: Rules,
    }
    impl Model {
        pub fn new_from_json() -> Model {
            return Model {
                provinces: serde_json::from_str(&get_map_data()).unwrap(),
                nav_tree: serde_json::from_str(&get_navtree_data()).unwrap(),
                players: ::alloc::vec::Vec::new(),
                rules: Rules {},
            };
        }
        pub fn get_prov_from_id_mut(&mut self, prov_id: &u32) -> Option<&mut Province> {
            for prov in &mut self.provinces {
                if prov.id == *prov_id {
                    return Some(prov);
                }
            }
            None
        }
        pub fn get_prov_from_id(&self, prov_id: &u32) -> Option<&Province> {
            for prov in &self.provinces {
                if prov.id == *prov_id {
                    return Some(prov);
                }
            }
            None
        }
        pub fn get_prov_name_from_id(&self, prov_id: &u32) -> String {
            let prov = self.get_prov_from_id(prov_id);
            if prov.is_some() {
                return prov.unwrap().name.clone();
            } else {
                "prov not found".to_string()
            }
        }
    }
    pub struct Rules {}
    impl Rules {
        pub fn armies_per_players_start(num_players: u32) -> Option<u32> {
            match num_players {
                0 | 1 => None,
                2 => Some(40),
                3 => Some(35),
                4 => Some(30),
                5 => Some(25),
                6 => Some(20),
                _ => None,
            }
        }
    }
    pub struct Coord {
        pub x: i32,
        pub y: i32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Coord {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Coord",
                "x",
                &self.x,
                "y",
                &&self.y,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Coord {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Coord",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "x",
                    &self.x,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "y",
                    &self.y,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Coord {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "x" => _serde::__private::Ok(__Field::__field0),
                            "y" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"x" => _serde::__private::Ok(__Field::__field0),
                            b"y" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Coord>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Coord;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Coord",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Coord with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Coord with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Coord { x: __field0, y: __field1 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("x"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("y"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("x")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("y")?
                            }
                        };
                        _serde::__private::Ok(Coord { x: __field0, y: __field1 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["x", "y"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Coord",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Coord>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for Coord {
        #[inline]
        fn clone(&self) -> Coord {
            Coord {
                x: ::core::clone::Clone::clone(&self.x),
                y: ::core::clone::Clone::clone(&self.y),
            }
        }
    }
    impl fmt::Display for Coord {
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            return f.write_fmt(format_args!("{{ x:{0}, y:{1} }}", self.x, self.y));
        }
    }
    pub enum Continent {
        Africa,
        SAmerica,
        NAmerica,
        Europe,
        Asia,
        Australia,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Continent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Continent::Africa => "Africa",
                    Continent::SAmerica => "SAmerica",
                    Continent::NAmerica => "NAmerica",
                    Continent::Europe => "Europe",
                    Continent::Asia => "Asia",
                    Continent::Australia => "Australia",
                },
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Continent {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Continent::Africa => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Continent",
                            0u32,
                            "Africa",
                        )
                    }
                    Continent::SAmerica => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Continent",
                            1u32,
                            "SAmerica",
                        )
                    }
                    Continent::NAmerica => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Continent",
                            2u32,
                            "NAmerica",
                        )
                    }
                    Continent::Europe => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Continent",
                            3u32,
                            "Europe",
                        )
                    }
                    Continent::Asia => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Continent",
                            4u32,
                            "Asia",
                        )
                    }
                    Continent::Australia => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Continent",
                            5u32,
                            "Australia",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Continent {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 6",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Africa" => _serde::__private::Ok(__Field::__field0),
                            "SAmerica" => _serde::__private::Ok(__Field::__field1),
                            "NAmerica" => _serde::__private::Ok(__Field::__field2),
                            "Europe" => _serde::__private::Ok(__Field::__field3),
                            "Asia" => _serde::__private::Ok(__Field::__field4),
                            "Australia" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Africa" => _serde::__private::Ok(__Field::__field0),
                            b"SAmerica" => _serde::__private::Ok(__Field::__field1),
                            b"NAmerica" => _serde::__private::Ok(__Field::__field2),
                            b"Europe" => _serde::__private::Ok(__Field::__field3),
                            b"Asia" => _serde::__private::Ok(__Field::__field4),
                            b"Australia" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Continent>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Continent;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Continent",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Continent::Africa)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Continent::SAmerica)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Continent::NAmerica)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Continent::Europe)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Continent::Asia)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Continent::Australia)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Africa",
                    "SAmerica",
                    "NAmerica",
                    "Europe",
                    "Asia",
                    "Australia",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Continent",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Continent>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for Continent {
        #[inline]
        fn clone(&self) -> Continent {
            match self {
                Continent::Africa => Continent::Africa,
                Continent::SAmerica => Continent::SAmerica,
                Continent::NAmerica => Continent::NAmerica,
                Continent::Europe => Continent::Europe,
                Continent::Asia => Continent::Asia,
                Continent::Australia => Continent::Australia,
            }
        }
    }
    impl fmt::Display for Continent {
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            match self {
                Continent::Africa => f.write_fmt(format_args!("Africa")),
                Continent::SAmerica => f.write_fmt(format_args!("South america")),
                Continent::Europe => f.write_fmt(format_args!("Europe")),
                Continent::NAmerica => f.write_fmt(format_args!("North america")),
                Continent::Asia => f.write_fmt(format_args!("Asia")),
                Continent::Australia => f.write_fmt(format_args!("Australia")),
            }
        }
    }
    pub enum TerritoryCardType {
        Infantry,
        Artillery,
        Cavalry,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TerritoryCardType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TerritoryCardType::Infantry => "Infantry",
                    TerritoryCardType::Artillery => "Artillery",
                    TerritoryCardType::Cavalry => "Cavalry",
                },
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TerritoryCardType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TerritoryCardType::Infantry => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TerritoryCardType",
                            0u32,
                            "Infantry",
                        )
                    }
                    TerritoryCardType::Artillery => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TerritoryCardType",
                            1u32,
                            "Artillery",
                        )
                    }
                    TerritoryCardType::Cavalry => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TerritoryCardType",
                            2u32,
                            "Cavalry",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TerritoryCardType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Infantry" => _serde::__private::Ok(__Field::__field0),
                            "Artillery" => _serde::__private::Ok(__Field::__field1),
                            "Cavalry" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Infantry" => _serde::__private::Ok(__Field::__field0),
                            b"Artillery" => _serde::__private::Ok(__Field::__field1),
                            b"Cavalry" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TerritoryCardType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TerritoryCardType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TerritoryCardType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TerritoryCardType::Infantry)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TerritoryCardType::Artillery)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TerritoryCardType::Cavalry)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Infantry",
                    "Artillery",
                    "Cavalry",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TerritoryCardType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TerritoryCardType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for TerritoryCardType {
        #[inline]
        fn clone(&self) -> TerritoryCardType {
            match self {
                TerritoryCardType::Infantry => TerritoryCardType::Infantry,
                TerritoryCardType::Artillery => TerritoryCardType::Artillery,
                TerritoryCardType::Cavalry => TerritoryCardType::Cavalry,
            }
        }
    }
    pub struct Province {
        pub name: String,
        pub id: u32,
        pub army_count: u32,
        pub owner_id: u32,
        pub location: Coord,
        pub continent: Continent,
        pub card_type: TerritoryCardType,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Province {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "id",
                "army_count",
                "owner_id",
                "location",
                "continent",
                "card_type",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.id,
                &self.army_count,
                &self.owner_id,
                &self.location,
                &self.continent,
                &&self.card_type,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Province",
                names,
                values,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Province {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Province",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "army_count",
                    &self.army_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "owner_id",
                    &self.owner_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "location",
                    &self.location,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "continent",
                    &self.continent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "card_type",
                    &self.card_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Province {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "id" => _serde::__private::Ok(__Field::__field1),
                            "army_count" => _serde::__private::Ok(__Field::__field2),
                            "owner_id" => _serde::__private::Ok(__Field::__field3),
                            "location" => _serde::__private::Ok(__Field::__field4),
                            "continent" => _serde::__private::Ok(__Field::__field5),
                            "card_type" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"id" => _serde::__private::Ok(__Field::__field1),
                            b"army_count" => _serde::__private::Ok(__Field::__field2),
                            b"owner_id" => _serde::__private::Ok(__Field::__field3),
                            b"location" => _serde::__private::Ok(__Field::__field4),
                            b"continent" => _serde::__private::Ok(__Field::__field5),
                            b"card_type" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Province>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Province;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Province",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Coord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Continent,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            TerritoryCardType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Province with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Province {
                            name: __field0,
                            id: __field1,
                            army_count: __field2,
                            owner_id: __field3,
                            location: __field4,
                            continent: __field5,
                            card_type: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Coord> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Continent> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<TerritoryCardType> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "army_count",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "owner_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "location",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Coord>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "continent",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Continent>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "card_type",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TerritoryCardType,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("army_count")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("owner_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("location")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("continent")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("card_type")?
                            }
                        };
                        _serde::__private::Ok(Province {
                            name: __field0,
                            id: __field1,
                            army_count: __field2,
                            owner_id: __field3,
                            location: __field4,
                            continent: __field5,
                            card_type: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "id",
                    "army_count",
                    "owner_id",
                    "location",
                    "continent",
                    "card_type",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Province",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Province>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Province {
        #[allow(dead_code)]
        pub fn from_i32_pair(x: i32, y: i32) -> Province {
            return Province {
                name: "none".to_string(),
                id: 0,
                army_count: 0,
                owner_id: 100,
                location: Coord { x, y },
                continent: Continent::Africa,
                card_type: TerritoryCardType::Infantry,
            };
        }
    }
    pub struct NavNode {
        id: u32,
        connections: Vec<u32>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NavNode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "NavNode",
                "id",
                &self.id,
                "connections",
                &&self.connections,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for NavNode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "NavNode",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "connections",
                    &self.connections,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NavNode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "connections" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"connections" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NavNode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NavNode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct NavNode",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct NavNode with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<u32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct NavNode with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(NavNode {
                            id: __field0,
                            connections: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<u32>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "connections",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u32>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("connections")?
                            }
                        };
                        _serde::__private::Ok(NavNode {
                            id: __field0,
                            connections: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "connections"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NavNode",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NavNode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl NavNode {
        #[allow(dead_code)]
        pub fn new(id: u32) -> NavNode {
            NavNode {
                id,
                connections: ::alloc::vec::Vec::new(),
            }
        }
    }
    type ProvId = u32;
    pub struct NavTree {
        nav_nodes: Vec<NavNode>,
        pub adding_id_set: bool,
        adding_to: u32,
        currently_selected: ProvId,
        pub selection_active: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NavTree {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "NavTree",
                "nav_nodes",
                &self.nav_nodes,
                "adding_id_set",
                &self.adding_id_set,
                "adding_to",
                &self.adding_to,
                "currently_selected",
                &self.currently_selected,
                "selection_active",
                &&self.selection_active,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for NavTree {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "NavTree",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nav_nodes",
                    &self.nav_nodes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "adding_id_set",
                    &self.adding_id_set,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "adding_to",
                    &self.adding_to,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "currently_selected",
                    &self.currently_selected,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "selection_active",
                    &self.selection_active,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NavTree {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "nav_nodes" => _serde::__private::Ok(__Field::__field0),
                            "adding_id_set" => _serde::__private::Ok(__Field::__field1),
                            "adding_to" => _serde::__private::Ok(__Field::__field2),
                            "currently_selected" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "selection_active" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"nav_nodes" => _serde::__private::Ok(__Field::__field0),
                            b"adding_id_set" => _serde::__private::Ok(__Field::__field1),
                            b"adding_to" => _serde::__private::Ok(__Field::__field2),
                            b"currently_selected" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"selection_active" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NavTree>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NavTree;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct NavTree",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<NavNode>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct NavTree with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct NavTree with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct NavTree with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ProvId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct NavTree with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct NavTree with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(NavTree {
                            nav_nodes: __field0,
                            adding_id_set: __field1,
                            adding_to: __field2,
                            currently_selected: __field3,
                            selection_active: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<NavNode>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<ProvId> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "nav_nodes",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<NavNode>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "adding_id_set",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "adding_to",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "currently_selected",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ProvId>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "selection_active",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nav_nodes")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("adding_id_set")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("adding_to")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("currently_selected")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("selection_active")?
                            }
                        };
                        _serde::__private::Ok(NavTree {
                            nav_nodes: __field0,
                            adding_id_set: __field1,
                            adding_to: __field2,
                            currently_selected: __field3,
                            selection_active: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "nav_nodes",
                    "adding_id_set",
                    "adding_to",
                    "currently_selected",
                    "selection_active",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NavTree",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NavTree>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(dead_code)]
    impl NavTree {
        pub fn new() -> NavTree {
            NavTree {
                nav_nodes: ::alloc::vec::Vec::new(),
                adding_id_set: false,
                adding_to: 0,
                currently_selected: 0,
                selection_active: false,
            }
        }
        pub fn select_prov(&mut self, prov_id: u32) {
            self.currently_selected = prov_id;
            self.selection_active = true;
        }
        pub fn deselect(&mut self) {
            self.selection_active = false;
        }
        fn validate_nav(&self, to: u32) -> bool {
            if !self.selection_active {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from(
                            "can't navigate, no selection",
                        ),
                    ]),
                );
                false;
            }
            if self.currently_selected == to {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from(
                            "can't navigate, to and from are the same",
                        ),
                    ]),
                );
                false;
            }
            true
        }
        pub fn navigate_adjacent(&self, to: u32) -> Option<bool> {
            if !self.validate_nav(to) {
                return None;
            }
            return Some(
                self
                    .get_node_from_id(&self.currently_selected)
                    .unwrap()
                    .connections
                    .contains(&to),
            );
        }
        pub fn navigate_move(&self, to: u32, provs: &Vec<Province>) -> Option<bool> {
            if !self.validate_nav(to) {
                return None;
            }
            let mut visited: Vec<u32> = Vec::new();
            let get_prov_with_id = |id: &u32| {
                for prov in provs {
                    if prov.id == *id {
                        return Some(prov);
                    }
                }
                None
            };
            let target_owner = get_prov_with_id(&self.currently_selected)
                .unwrap()
                .owner_id;
            let mut visit_q: Queue<&Province> = Queue::new();
            let _ = visit_q.add(get_prov_with_id(&self.currently_selected).unwrap());
            while visit_q.size() > 0 {
                let curr_prov_id = visit_q.remove().unwrap().id;
                visited.push(curr_prov_id);
                let adjacent = self.get_node_from_id(&curr_prov_id).unwrap();
                let next: Vec<_> = adjacent
                    .connections
                    .iter()
                    .filter(|prov_id| { !visited.contains(prov_id) })
                    .filter(|prov_id| {
                        get_prov_with_id(prov_id).unwrap().owner_id == target_owner
                    })
                    .collect();
                for id in next {
                    if *id == to {
                        return Some(true);
                    } else {
                        let _ = visit_q.add(get_prov_with_id(&id).unwrap());
                    }
                }
            }
            Some(false)
        }
        pub fn add_node(&mut self, id: u32) {
            if self.adding_id_set {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from({
                            let res = ::alloc::fmt::format(
                                format_args!("already adding to id {0}", self.adding_to),
                            );
                            res
                        }),
                    ]),
                );
                return;
            }
            for node in &self.nav_nodes {
                if node.id == id {
                    ::gloo_console::externs::log(
                        ::std::boxed::Box::from([
                            ::gloo_console::__macro::JsValue::from(
                                " can't add node is already in list",
                            ),
                        ]),
                    );
                    return;
                }
            }
            self.nav_nodes.push(NavNode::new(id));
            self.adding_id_set = true;
            self.adding_to = id;
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from("added new node"),
                ]),
            )
        }
        pub fn add_connection(&mut self, dest: u32) {
            if self.adding_to == dest {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from(
                            "add failed to and from are the same",
                        ),
                    ]),
                );
                return;
            }
            if !(self.adding_id_set) {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from("adding id not set"),
                    ]),
                );
                return;
            }
            for node in &mut self.nav_nodes {
                if node.id == self.adding_to {
                    if !node.connections.contains(&dest) {
                        node.connections.push(dest);
                        ::gloo_console::externs::log(
                            ::std::boxed::Box::from([
                                ::gloo_console::__macro::JsValue::from({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "added path from {0} to {1}",
                                            self.adding_to,
                                            dest,
                                        ),
                                    );
                                    res
                                }),
                            ]),
                        );
                        return;
                    } else {
                        ::gloo_console::externs::log(
                            ::std::boxed::Box::from([
                                ::gloo_console::__macro::JsValue::from(
                                    "dest is already in node",
                                ),
                            ]),
                        );
                    }
                }
            }
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "add failed could not find id {0} in nav tree",
                                self.adding_to,
                            ),
                        );
                        res
                    }),
                ]),
            )
        }
        pub fn verify_self(&self) {
            for node in &self.nav_nodes {
                for id in &node.connections {
                    if !self.get_node_from_id(id).unwrap().connections.contains(&node.id)
                    {
                        ::gloo_console::externs::log(
                            ::std::boxed::Box::from([
                                ::gloo_console::__macro::JsValue::from({
                                    let res = ::alloc::fmt::format(
                                        format_args!("node {0} is missing connections", node.id),
                                    );
                                    res
                                }),
                            ]),
                        );
                        return;
                    }
                }
            }
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from("success"),
                ]),
            )
        }
        pub fn end_add(&mut self) {
            self.adding_id_set = false;
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from({
                        let res = ::alloc::fmt::format(
                            format_args!("finished adding to {0}", self.adding_to),
                        );
                        res
                    }),
                ]),
            )
        }
        fn get_node_from_id(&self, id: &u32) -> Option<&NavNode> {
            for node in &self.nav_nodes {
                if node.id == *id {
                    return Some(node);
                }
            }
            None
        }
    }
    pub struct Player {
        pub id: u32,
        pub cards: Vec<TerritoryCardType>,
        pub color: String,
        pub is_computer: bool,
    }
    impl Player {
        #[allow(dead_code)]
        fn new(id: u32, color: String, is_computer: bool) -> Player {
            return Player {
                id,
                cards: ::alloc::vec::Vec::new(),
                color,
                is_computer,
            };
        }
        pub fn get_owned_provs<'a>(
            &self,
            provs: &'a Vec<Province>,
        ) -> Vec<&'a Province> {
            let mut ret: Vec<&Province> = Vec::new();
            for prov in provs {
                if prov.owner_id == self.id {
                    ret.push(prov)
                }
            }
            ret
        }
    }
}
mod game {
    use js_sys::Math::sqrt;
    use crate::element_getters::set_info_field;
    use crate::model::{Coord, Model, Player, Rules};
    use crate::ui::player_setup::PlayerConfig;
    use crate::utils::funcs::rand_int;
    use gloo::console::log as console_log;
    use crate::ui::structs::{UiInfo, UiUpdatable};
    use crate::ui::main::UiState;
    pub struct ProvLookupTable {
        pub pixels: Vec<[u8; 3]>,
        pub width: u32,
        pub max_div: u32,
    }
    impl ProvLookupTable {
        fn get_coord(&self, coord: &Coord) -> [u8; 3] {
            let idx = (coord.x + coord.y * self.width as i32) as usize;
            return self.pixels[idx];
        }
        fn compare_colors(&self, target: &Coord, compare: &Coord) -> bool {
            let mut color_div_acc = 0;
            let color_target = self.get_coord(target);
            let color_compare = self.get_coord(compare);
            for i in 0..color_target.len() {
                color_div_acc
                    += (color_target[i] as i32 - color_compare[i] as i32).abs();
            }
            return color_div_acc < self.max_div as i32;
        }
        fn dist_between_pnts(pnt1: &Coord, pnt2: &Coord) -> i32 {
            sqrt((pnt1.x - pnt2.x).pow(2) as f64 + (pnt1.y - pnt2.y).pow(2) as f64)
                as i32
        }
    }
    pub struct Game {
        pub model: Model,
        prov_lookup: ProvLookupTable,
        flag_scale: f64,
        ui_info: UiInfo,
    }
    impl Game {
        pub fn new(prov_lookup: ProvLookupTable) -> Game {
            return Game {
                model: Model::new_from_json(),
                prov_lookup,
                flag_scale: 0.5,
                ui_info: UiInfo::new(),
            };
        }
        pub fn draw_board(&self) {
            if self.model.players.len() > 0 {
                crate::canvas::redraw_board_state(&self.model, self.flag_scale, true);
            } else {
                crate::canvas::redraw_board_state(&self.model, self.flag_scale, false);
            }
        }
        fn assign_provs_random(&mut self) {
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from({
                        let res = ::alloc::fmt::format(
                            format_args!("players len = {0}", self.model.players.len()),
                        );
                        res
                    }),
                ]),
            );
            let player_count = self.model.players.len() as i32;
            for i in 0..self.model.provinces.len() {
                let idx = rand_int(0, player_count as u32) as i32;
                if idx < player_count {
                    self.model.provinces[i].owner_id = idx as u32;
                    self.model.provinces[i].army_count = 1;
                }
            }
        }
        pub fn set_player_config(&mut self, config: PlayerConfig) {
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from({
                        let res = ::alloc::fmt::format(
                            format_args!("player count = {0}", config.player_count),
                        );
                        res
                    }),
                ]),
            );
            for i in 0..config.player_count {
                self.model
                    .players
                    .push(Player {
                        id: i as u32,
                        cards: ::alloc::vec::Vec::new(),
                        color: config.player_colors[i as usize].clone(),
                        is_computer: config.player_is_ai[i as usize],
                    })
            }
            let armies_per_player = Rules::armies_per_players_start(
                    config.player_count as u32,
                )
                .unwrap();
            self.assign_provs_random();
            let provs = &self.model.provinces;
            self.ui_info
                .start_placement
                .set(
                    self
                        .ui_info
                        .start_placement
                        .get()
                        .update(|tmp| {
                            tmp.num_players = config.player_count as u32;
                            for i in 0..tmp.num_players as usize {
                                let armies = armies_per_player
                                    - self.model.players[i].get_owned_provs(provs).len() as u32;
                                ::gloo_console::externs::log(
                                    ::std::boxed::Box::from([
                                        ::gloo_console::__macro::JsValue::from({
                                            let res = ::alloc::fmt::format(
                                                format_args!("found {0} armies for player {1}", armies, i),
                                            );
                                            res
                                        }),
                                    ]),
                                );
                                tmp.armies_per_player[i] = armies;
                            }
                        }),
                );
            self.draw_board();
        }
        pub fn get_prov_location_string(&self, coord: &Coord) -> Option<String> {
            let prov_id = self.lookup_coord(coord);
            if prov_id.is_some() {
                let prov = &self.model.provinces[prov_id.unwrap() as usize];
                return Some({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "found {0} on continent {1}",
                            prov.name,
                            prov.continent,
                        ),
                    );
                    res
                });
            } else {
                return None
            }
        }
        pub fn get_prov_mouseover_string(&self, coord: &Coord) -> Option<String> {
            let prov_id = self.lookup_coord(coord);
            if prov_id.is_some() {
                let prov = &self.model.provinces[prov_id.unwrap() as usize];
                return Some(prov.name.clone());
            } else {
                return None
            }
        }
        pub fn lookup_coord(&self, clicked_coord: &Coord) -> Option<u32> {
            let mut found_at_idx: Vec<i32> = Vec::new();
            for i in 0..self.model.provinces.len() {
                if self
                    .prov_lookup
                    .compare_colors(&self.model.provinces[i].location, &clicked_coord)
                {
                    found_at_idx.push(i as i32);
                }
            }
            if found_at_idx.len() == 0 {
                None
            } else if found_at_idx.len() == 1 {
                Some(found_at_idx[0] as u32)
            } else {
                let mut idx_shortest: i32 = -1;
                let mut shortest_dist = i32::MAX;
                for idx in found_at_idx {
                    let dist = ProvLookupTable::dist_between_pnts(
                        &clicked_coord,
                        &self.model.provinces[idx as usize].location,
                    );
                    if dist < shortest_dist {
                        shortest_dist = dist;
                        idx_shortest = idx;
                    }
                }
                Some(idx_shortest as u32)
            }
        }
        pub fn handle_canvas_click(&mut self, clicked_coord: Coord) {
            let prov_str = self.get_prov_location_string(&clicked_coord);
            if prov_str.is_some() {
                set_info_field(prov_str.unwrap());
            } else {
                set_info_field("".to_owned());
            }
            let prov_id_opt = self.lookup_coord(&clicked_coord);
            if prov_id_opt.is_some() {
                let prov_id = prov_id_opt.unwrap();
                match *self.ui_info.ui_state.get() {
                    UiState::SETUP => {}
                    UiState::ARMY_PLACEMENT_START => {
                        self.handle_army_placement(prov_id, true)
                    }
                    UiState::ARMY_PLACEMENT => self.handle_army_placement(prov_id, false),
                    UiState::TURN_START => {}
                    UiState::TURN => {}
                    UiState::COMBAT => {}
                    UiState::GAME_END => {}
                    UiState::CARD_SELECT => {}
                }
            }
        }
        fn handle_army_placement(&mut self, prov_id: u32, placement_start: bool) {
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "running placement id {0}, start {1}",
                                prov_id,
                                placement_start,
                            ),
                        );
                        res
                    }),
                ]),
            );
            let armies_available: u32 = if placement_start {
                let tmp = *self.ui_info.start_placement.get();
                tmp.armies_per_player[tmp.current_player as usize]
            } else {
                let tmp = *self.ui_info.placement.get();
                tmp.army_count
            };
            if armies_available > 0 {
                self.change_armies_in_prov(1, &prov_id);
                if placement_start {
                    self.ui_info
                        .start_placement
                        .set(
                            self
                                .ui_info
                                .start_placement
                                .get()
                                .update(|tmp| {
                                    tmp
                                        .armies_per_player[tmp.current_player
                                        as usize] = armies_available - 1;
                                    if armies_available == 1 {
                                        tmp.is_done = true;
                                    }
                                }),
                        )
                } else {
                    self.ui_info
                        .placement
                        .set(
                            self
                                .ui_info
                                .placement
                                .get()
                                .update(|tmp| {
                                    tmp.army_count = armies_available - 1;
                                    if armies_available == 1 {
                                        tmp.is_done = true;
                                    }
                                }),
                        )
                }
            } else {
                if placement_start {
                    {
                        ::std::rt::panic_fmt(
                            format_args!(
                                "in placement state, with 0 armies to place {0:?}",
                                self.ui_info.start_placement.get(),
                            ),
                        );
                    };
                } else {
                    {
                        ::std::rt::panic_fmt(
                            format_args!(
                                "in placement state, with 0 armies to place {0:?}",
                                self.ui_info.placement.get(),
                            ),
                        );
                    };
                };
            }
            self.draw_board();
        }
        pub fn nav_tree_end_add(&mut self) {
            self.model.nav_tree.end_add();
        }
        pub fn nav_tree_dump(&self) {
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from("dumping"),
                ]),
            );
            ::gloo_console::externs::log(
                ::std::boxed::Box::from([
                    ::gloo_console::__macro::JsValue::from(
                        serde_json::to_string(&self.model.nav_tree).unwrap(),
                    ),
                ]),
            );
        }
        pub fn nav_tree_check(&self) {
            self.model.nav_tree.verify_self();
        }
        pub fn change_armies_in_prov(&mut self, num_armies: i32, prov_id: &u32) {
            let prov = self
                .model
                .get_prov_from_id_mut(prov_id)
                .expect(
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("prov with id {0} could not be found", prov_id),
                        );
                        res
                    }
                        .as_str(),
                );
            let old_army_count = prov.army_count;
            let new_army_count = old_army_count as i32 + num_armies;
            if new_army_count > -1 {
                prov.army_count = new_army_count as u32;
            } else {
                prov.army_count = 0;
            }
        }
        pub fn get_ui_info_clone(&self) -> UiInfo {
            return self.ui_info.clone();
        }
    }
}
mod utils {
    pub mod consts {
        pub const MAX_PLAYERS: usize = 8;
    }
    pub mod funcs {
        #![allow(dead_code)]
        use std::cell::RefCell;
        use std::rc::Rc;
        use js_sys::Math::random;
        use wasm_bindgen::closure::Closure;
        use wasm_bindgen::JsCast;
        use web_sys::MouseEvent;
        use crate::element_getters::get_button_by_id;
        use crate::game::Game;
        pub fn rand_int(lower: u32, upper: u32) -> u32 {
            let diff = upper - lower;
            let mut res = lower + (random() * diff as f64) as u32;
            if res == upper {
                res = res - 1;
            }
            return res;
        }
        pub fn rand_int_inclusive(lower: u32, upper: u32) -> u32 {
            let diff = upper - lower;
            return lower + (random() * diff as f64) as u32;
        }
        pub fn setup_tree_builder_btns(game: Rc<RefCell<Game>>) {
            let game_ref_btn2 = game.clone();
            let game_ref_btn3 = game.clone();
            let start = get_button_by_id("nav_start");
            let end = get_button_by_id("nav_end");
            let dump = get_button_by_id("nav_dump");
            let closure_start = Closure::<
                dyn FnMut(_),
            >::new(move |_event: MouseEvent| {
                game_ref_btn3.as_ref().borrow_mut().nav_tree_check();
            });
            let _ = start
                .add_event_listener_with_callback(
                    "click",
                    closure_start.as_ref().unchecked_ref(),
                );
            closure_start.forget();
            let closure_end = Closure::<
                dyn FnMut(_),
            >::new(move |_event: MouseEvent| {
                game.as_ref().borrow_mut().nav_tree_end_add();
            });
            let _ = end
                .add_event_listener_with_callback(
                    "click",
                    closure_end.as_ref().unchecked_ref(),
                );
            closure_end.forget();
            let closure_dump = Closure::<
                dyn FnMut(_),
            >::new(move |_event: MouseEvent| {
                game_ref_btn2.as_ref().borrow().nav_tree_dump();
            });
            let _ = dump
                .add_event_listener_with_callback(
                    "click",
                    closure_dump.as_ref().unchecked_ref(),
                );
            closure_dump.forget();
        }
    }
}
mod data_include {
    pub fn get_map_data() -> String {
        let data = r#"[
  {
    "name": "Alaska",
    "id": 0,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 68,
      "y": 57
    },
    "continent": "NAmerica",
    "card_type": "Infantry"
  },
  {
    "name": "Northwest Territory",
    "id": 1,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 113,
      "y": 62
    },
    "continent": "NAmerica",
    "card_type": "Artillery"
  },
  {
    "name": "Alberta",
    "id": 2,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 109,
      "y": 92
    },
    "continent": "NAmerica",
    "card_type": "Cavalry"
  },
  {
    "name": "Ontario",
    "id": 3,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 162,
      "y": 97
    },
    "continent": "NAmerica",
    "card_type": "Cavalry"
  },
  {
    "name": "Quebec",
    "id": 4,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 221,
      "y": 92
    },
    "continent": "NAmerica",
    "card_type": "Cavalry"
  },
  {
    "name": "Greenland",
    "id": 5,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 309,
      "y": 34
    },
    "continent": "NAmerica",
    "card_type": "Cavalry"
  },
  {
    "name": "Western United States",
    "id": 6,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 104,
      "y": 127
    },
    "continent": "NAmerica",
    "card_type": "Artillery"
  },
  {
    "name": "Eastern United States",
    "id": 7,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 153,
      "y": 151
    },
    "continent": "NAmerica",
    "card_type": "Artillery"
  },
  {
    "name": "Central America",
    "id": 8,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 97,
      "y": 191
    },
    "continent": "NAmerica",
    "card_type": "Artillery"
  },
  {
    "name": "Venezuela",
    "id": 9,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 179,
      "y": 251
    },
    "continent": "SAmerica",
    "card_type": "Infantry"
  },
  {
    "name": "Brazil",
    "id": 10,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 218,
      "y": 301
    },
    "continent": "SAmerica",
    "card_type": "Artillery"
  },
  {
    "name": "Peru",
    "id": 11,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 192,
      "y": 325
    },
    "continent": "SAmerica",
    "card_type": "Infantry"
  },
  {
    "name": "Argentina",
    "id": 12,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 207,
      "y": 387
    },
    "continent": "SAmerica",
    "card_type": "Infantry"
  },
  {
    "name": "North Africa",
    "id": 13,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 380,
      "y": 195
    },
    "continent": "Africa",
    "card_type": "Cavalry"
  },
  {
    "name": "Egypt",
    "id": 14,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 439,
      "y": 182
    },
    "continent": "Africa",
    "card_type": "Infantry"
  },
  {
    "name": "East Africa",
    "id": 15,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 483,
      "y": 236
    },
    "continent": "Africa",
    "card_type": "Infantry"
  },
  {
    "name": "Congo",
    "id": 16,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 449,
      "y": 288
    },
    "continent": "Africa",
    "card_type": "Infantry"
  },
  {
    "name": "South Africa",
    "id": 17,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 451,
      "y": 340
    },
    "continent": "Africa",
    "card_type": "Artillery"
  },
  {
    "name": "Madagascar",
    "id": 18,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 519,
      "y": 343
    },
    "continent": "Africa",
    "card_type": "Cavalry"
  },
  {
    "name": "Iceland",
    "id": 19,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 353,
      "y": 59
    },
    "continent": "Europe",
    "card_type": "Infantry"
  },
  {
    "name": "Great Britain & Ireland",
    "id": 20,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 386,
      "y": 95
    },
    "continent": "Europe",
    "card_type": "Artillery"
  },
  {
    "name": "Scandinavia",
    "id": 21,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 424,
      "y": 69
    },
    "continent": "Europe",
    "card_type": "Cavalry"
  },
  {
    "name": "Central Europe",
    "id": 22,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 425,
      "y": 101
    },
    "continent": "Europe",
    "card_type": "Cavalry"
  },
  {
    "name": "Eastern Europe",
    "id": 23,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 473,
      "y": 81
    },
    "continent": "Europe",
    "card_type": "Cavalry"
  },
  {
    "name": "Southern Europe",
    "id": 24,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 447,
      "y": 126
    },
    "continent": "Europe",
    "card_type": "Artillery"
  },
  {
    "name": "Western Europe",
    "id": 25,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 395,
      "y": 115
    },
    "continent": "Europe",
    "card_type": "Artillery"
  },
  {
    "name": "Middle East",
    "id": 26,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 505,
      "y": 160
    },
    "continent": "Asia",
    "card_type": "Infantry"
  },
  {
    "name": "Afghanistan",
    "id": 27,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 550,
      "y": 117
    },
    "continent": "Asia",
    "card_type": "Cavalry"
  },
  {
    "name": "Ural",
    "id": 28,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 558,
      "y": 74
    },
    "continent": "Asia",
    "card_type": "Cavalry"
  },
  {
    "name": "Siberia",
    "id": 29,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 607,
      "y": 51
    },
    "continent": "Asia",
    "card_type": "Cavalry"
  },
  {
    "name": "Yakutsk",
    "id": 30,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 679,
      "y": 61
    },
    "continent": "Asia",
    "card_type": "Cavalry"
  },
  {
    "name": "Kamchatka",
    "id": 31,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 728,
      "y": 66
    },
    "continent": "Asia",
    "card_type": "Infantry"
  },
  {
    "name": "Japan",
    "id": 32,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 766,
      "y": 149
    },
    "continent": "Asia",
    "card_type": "Artillery"
  },
  {
    "name": "Mongolia",
    "id": 33,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 659,
      "y": 122
    },
    "continent": "Asia",
    "card_type": "Infantry"
  },
  {
    "name": "China",
    "id": 34,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 650,
      "y": 158
    },
    "continent": "Asia",
    "card_type": "Infantry"
  },
  {
    "name": "India",
    "id": 35,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 603,
      "y": 191
    },
    "continent": "Asia",
    "card_type": "Cavalry"
  },
  {
    "name": "Irkutsk",
    "id": 36,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 653,
      "y": 86
    },
    "continent": "Asia",
    "card_type": "Cavalry"
  },
  {
    "name": "Southeast Asia",
    "id": 37,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 678,
      "y": 219
    },
    "continent": "Asia",
    "card_type": "Infantry"
  },
  {
    "name": "Indonesia",
    "id": 38,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 712,
      "y": 280
    },
    "continent": "Australia",
    "card_type": "Artillery"
  },
  {
    "name": "New Guinea",
    "id": 39,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 797,
      "y": 295
    },
    "continent": "Africa",
    "card_type": "Infantry"
  },
  {
    "name": "Western Australia",
    "id": 40,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 730,
      "y": 375
    },
    "continent": "Australia",
    "card_type": "Artillery"
  },
  {
    "name": "Eastern Australia",
    "id": 41,
    "owner_id": 100,
    "army_count": 0,
    "location": {
      "x": 792,
      "y": 360
    },
    "continent": "Australia",
    "card_type": "Artillery"
  }
]"#;
        return data.to_string();
    }
    pub fn get_navtree_data() -> String {
        let data = r#"
    {
    "nav_nodes": [
        {
            "id": 11,
            "connections": [
                12,
                10,
                9
            ]
        },
        {
            "id": 12,
            "connections": [
                11,
                10
            ]
        },
        {
            "id": 10,
            "connections": [
                9,
                11,
                12,
                13
            ]
        },
        {
            "id": 9,
            "connections": [
                11,
                10,
                8
            ]
        },
        {
            "id": 8,
            "connections": [
                6,
                7,
                9
            ]
        },
        {
            "id": 6,
            "connections": [
                8,
                7,
                3,
                2
            ]
        },
        {
            "id": 7,
            "connections": [
                6,
                8,
                4,
                3,
                2
            ]
        },
        {
            "id": 2,
            "connections": [
                6,
                7,
                3,
                1,
                0
            ]
        },
        {
            "id": 3,
            "connections": [
                1,
                2,
                6,
                7,
                4,
                5
            ]
        },
        {
            "id": 4,
            "connections": [
                3,
                7,
                5
            ]
        },
        {
            "id": 1,
            "connections": [
                0,
                2,
                3,
                5
            ]
        },
        {
            "id": 0,
            "connections": [
                2,
                1,
                31
            ]
        },
        {
            "id": 5,
            "connections": [
                1,
                3,
                4,
                19
            ]
        },
        {
            "id": 20,
            "connections": [
                19,
                21,
                22,
                25
            ]
        },
        {
            "id": 21,
            "connections": [
                19,
                20,
                22,
                23
            ]
        },
        {
            "id": 22,
            "connections": [
                20,
                25,
                24,
                23,
                21
            ]
        },
        {
            "id": 25,
            "connections": [
                13,
                24,
                22,
                20
            ]
        },
        {
            "id": 24,
            "connections": [
                25,
                22,
                23,
                26,
                14
            ]
        },
        {
            "id": 23,
            "connections": [
                21,
                22,
                24,
                26,
                27,
                28
            ]
        },
        {
            "id": 13,
            "connections": [
                10,
                25,
                14,
                15,
                16
            ]
        },
        {
            "id": 16,
            "connections": [
                13,
                15,
                17
            ]
        },
        {
            "id": 17,
            "connections": [
                16,
                15,
                18
            ]
        },
        {
            "id": 18,
            "connections": [
                17,
                15
            ]
        },
        {
            "id": 14,
            "connections": [
                13,
                15,
                26,
                24
            ]
        },
        {
            "id": 15,
            "connections": [
                14,
                13,
                16,
                17,
                18,
                26
            ]
        },
        {
            "id": 26,
            "connections": [
                14,
                15,
                35,
                27,
                23,
                24
            ]
        },
        {
            "id": 27,
            "connections": [
                23,
                26,
                35,
                34,
                28
            ]
        },
        {
            "id": 28,
            "connections": [
                23,
                27,
                34,
                29
            ]
        },
        {
            "id": 29,
            "connections": [
                28,
                34,
                33,
                36,
                30
            ]
        },
        {
            "id": 30,
            "connections": [
                29,
                36,
                31
            ]
        },
        {
            "id": 31,
            "connections": [
                30,
                36,
                33,
                32,
                0
            ]
        },
        {
            "id": 36,
            "connections": [
                29,
                33,
                31,
                30
            ]
        },
        {
            "id": 33,
            "connections": [
                34,
                29,
                36,
                31,
                32
            ]
        },
        {
            "id": 34,
            "connections": [
                33,
                29,
                28,
                27,
                35,
                37
            ]
        },
        {
            "id": 35,
            "connections": [
                26,
                27,
                34,
                37
            ]
        },
        {
            "id": 32,
            "connections": [
                33,
                31
            ]
        },
        {
            "id": 37,
            "connections": [
                34,
                35,
                38
            ]
        },
        {
            "id": 38,
            "connections": [
                37,
                40,
                39,
                41
            ]
        },
        {
            "id": 39,
            "connections": [
                41,
                40,
                38
            ]
        },
        {
            "id": 40,
            "connections": [
                41,
                39,
                38
            ]
        },
        {
            "id": 41,
            "connections": [
                40,
                38,
                39
            ]
        },
        {
            "id": 19,
            "connections": [
                5,
                20,
                21
            ]
        }
    ],
    "adding_id_set": false,
    "adding_to": 19,
    "currently_selected": 0,
    "selection_active": false
}"#;
        return data.to_string();
    }
    pub fn get_colors_array() -> [&'static str; 6] {
        ["CadetBlue", "DarkOrchid", "DarkKhaki", "LimeGreen", "OrangeRed", "PeachPuff"]
    }
}
mod ui {
    pub mod player_setup {
        use std::cell::RefCell;
        use sycamore::prelude::*;
        use std::rc::Rc;
        use wasm_bindgen::JsCast;
        use web_sys::{Event, HtmlInputElement, HtmlSelectElement};
        use crate::data_include::get_colors_array;
        use crate::game::Game;
        use crate::ui::main::UiState;
        pub struct PlayerConfig {
            pub player_count: i32,
            pub player_colors: Vec<String>,
            pub player_is_ai: Vec<bool>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PlayerConfig {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "PlayerConfig",
                    "player_count",
                    &self.player_count,
                    "player_colors",
                    &self.player_colors,
                    "player_is_ai",
                    &&self.player_is_ai,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PlayerConfig {
            #[inline]
            fn clone(&self) -> PlayerConfig {
                PlayerConfig {
                    player_count: ::core::clone::Clone::clone(&self.player_count),
                    player_colors: ::core::clone::Clone::clone(&self.player_colors),
                    player_is_ai: ::core::clone::Clone::clone(&self.player_is_ai),
                }
            }
        }
        impl PlayerConfig {
            fn new() -> PlayerConfig {
                PlayerConfig {
                    player_count: 2,
                    player_colors: ::alloc::vec::Vec::new(),
                    player_is_ai: ::alloc::vec::Vec::new(),
                }
            }
        }
        pub struct PlayerConfigProps<'a> {
            pub idx: i32,
            data: &'a Signal<PlayerConfig>,
            done: &'a Signal<bool>,
        }
        impl<'a> ::sycamore::component::Prop for PlayerConfigProps<'a> {
            type Builder = PlayerConfigPropsBuilder<'a, ((), (), ())>;
            /**
                    Create a builder for building `PlayerConfigProps`.
                    On the builder, call `.idx(...)`, `.data(...)`, `.done(...)` to set the values of the fields.
                    Finally, call `.build()` to create the instance of `PlayerConfigProps`.
                    */
            #[allow(dead_code, clippy::default_trait_access)]
            fn builder() -> Self::Builder {
                PlayerConfigPropsBuilder {
                    fields: ((), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct PlayerConfigPropsBuilder<'a, PropFields> {
            fields: PropFields,
            phantom: (::core::marker::PhantomData<&'a ()>),
        }
        impl<'a, PropFields> Clone for PlayerConfigPropsBuilder<'a, PropFields>
        where
            PropFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait PlayerConfigPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> PlayerConfigPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> PlayerConfigPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, __done, __data> PlayerConfigPropsBuilder<'a, ((), __data, __done)> {
            pub fn idx(
                self,
                idx: i32,
            ) -> PlayerConfigPropsBuilder<'a, ((i32,), __data, __done)> {
                let idx = (idx,);
                let (_, data, done) = self.fields;
                PlayerConfigPropsBuilder {
                    fields: (idx, data, done),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayerConfigPropsBuilder_Error_Repeated_field_idx {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, __done, __data> PlayerConfigPropsBuilder<'a, ((i32,), __data, __done)> {
            #[deprecated(note = "Repeated field idx")]
            pub fn idx(
                self,
                _: PlayerConfigPropsBuilder_Error_Repeated_field_idx,
            ) -> PlayerConfigPropsBuilder<'a, ((i32,), __data, __done)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, __done, __idx> PlayerConfigPropsBuilder<'a, (__idx, (), __done)> {
            pub fn data(
                self,
                data: &'a Signal<PlayerConfig>,
            ) -> PlayerConfigPropsBuilder<
                'a,
                (__idx, (&'a Signal<PlayerConfig>,), __done),
            > {
                let data = (data,);
                let (idx, _, done) = self.fields;
                PlayerConfigPropsBuilder {
                    fields: (idx, data, done),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayerConfigPropsBuilder_Error_Repeated_field_data {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __done,
            __idx,
        > PlayerConfigPropsBuilder<'a, (__idx, (&'a Signal<PlayerConfig>,), __done)> {
            #[deprecated(note = "Repeated field data")]
            pub fn data(
                self,
                _: PlayerConfigPropsBuilder_Error_Repeated_field_data,
            ) -> PlayerConfigPropsBuilder<
                'a,
                (__idx, (&'a Signal<PlayerConfig>,), __done),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, __data, __idx> PlayerConfigPropsBuilder<'a, (__idx, __data, ())> {
            pub fn done(
                self,
                done: &'a Signal<bool>,
            ) -> PlayerConfigPropsBuilder<'a, (__idx, __data, (&'a Signal<bool>,))> {
                let done = (done,);
                let (idx, data, _) = self.fields;
                PlayerConfigPropsBuilder {
                    fields: (idx, data, done),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayerConfigPropsBuilder_Error_Repeated_field_done {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __data,
            __idx,
        > PlayerConfigPropsBuilder<'a, (__idx, __data, (&'a Signal<bool>,))> {
            #[deprecated(note = "Repeated field done")]
            pub fn done(
                self,
                _: PlayerConfigPropsBuilder_Error_Repeated_field_done,
            ) -> PlayerConfigPropsBuilder<'a, (__idx, __data, (&'a Signal<bool>,))> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayerConfigPropsBuilder_Error_Missing_required_field_idx {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<'a, __done, __data> PlayerConfigPropsBuilder<'a, ((), __data, __done)> {
            #[deprecated(note = "Missing required field idx")]
            pub fn build(
                self,
                _: PlayerConfigPropsBuilder_Error_Missing_required_field_idx,
            ) -> PlayerConfigProps<'a> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayerConfigPropsBuilder_Error_Missing_required_field_data {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<'a, __done> PlayerConfigPropsBuilder<'a, ((i32,), (), __done)> {
            #[deprecated(note = "Missing required field data")]
            pub fn build(
                self,
                _: PlayerConfigPropsBuilder_Error_Missing_required_field_data,
            ) -> PlayerConfigProps<'a> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayerConfigPropsBuilder_Error_Missing_required_field_done {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
        > PlayerConfigPropsBuilder<'a, ((i32,), (&'a Signal<PlayerConfig>,), ())> {
            #[deprecated(note = "Missing required field done")]
            pub fn build(
                self,
                _: PlayerConfigPropsBuilder_Error_Missing_required_field_done,
            ) -> PlayerConfigProps<'a> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
        > PlayerConfigPropsBuilder<
            'a,
            ((i32,), (&'a Signal<PlayerConfig>,), (&'a Signal<bool>,)),
        > {
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> PlayerConfigProps<'a> {
                let (idx, data, done) = self.fields;
                let idx = idx.0;
                let data = data.0;
                let done = done.0;
                PlayerConfigProps {
                    idx,
                    data,
                    done,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for PlayerConfigProps<'a> {
            #[inline]
            fn clone(&self) -> PlayerConfigProps<'a> {
                let _: ::core::clone::AssertParamIsClone<i32>;
                let _: ::core::clone::AssertParamIsClone<&'a Signal<PlayerConfig>>;
                let _: ::core::clone::AssertParamIsClone<&'a Signal<bool>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for PlayerConfigProps<'a> {}
        #[allow(non_snake_case)]
        pub fn PlayerSetup<'a, G: Html>(
            cx: Scope<'a>,
            props: PlayerConfigProps<'a>,
        ) -> View<G> {
            let checkbox_handle = move |e: Event| {
                let input_elem = e
                    .target()
                    .unwrap()
                    .dyn_ref::<HtmlInputElement>()
                    .unwrap()
                    .clone();
                let is_checked = input_elem.checked();
                let idx = props.idx as usize;
                let mut tmp_player_config = (*props.data.get()).clone();
                tmp_player_config.player_is_ai[idx - 1] = is_checked;
                props.data.set(tmp_player_config);
            };
            {
                #[allow(unused_variables)]
                let cx: ::sycamore::reactive::BoundedScope = cx;
                ::sycamore::view::View::new_node({
                    let __el = ::sycamore::generic_node::GenericNode::element::<
                        ::sycamore::web::html::div,
                    >();
                    ::sycamore::generic_node::GenericNode::set_attribute(
                        &__el,
                        "style",
                        if false {
                            ::sycamore::rt::intern(" padding-bottom:15px")
                        } else {
                            " padding-bottom:15px"
                        },
                    );
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &{
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::label,
                            >();
                            ::sycamore::generic_node::GenericNode::append_child(
                                &__el,
                                &::sycamore::generic_node::GenericNode::text_node("Player "),
                            );
                            let __view = ::sycamore::view::View::new_dyn(
                                cx,
                                move || ::sycamore::view::IntoView::create(&(props.idx)),
                            );
                            let __initial = ::sycamore::utils::initial_node(&__el);
                            let __marker = ::std::option::Option::None;
                            ::sycamore::utils::render::insert(
                                cx,
                                &__el,
                                __view,
                                __initial,
                                __marker,
                                true,
                            );
                            __el
                        },
                    );
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &{
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::div,
                            >();
                            __el
                        },
                    );
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &{
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::input,
                            >();
                            ::sycamore::generic_node::GenericNode::set_attribute(
                                &__el,
                                "type",
                                if false {
                                    ::sycamore::rt::intern("checkbox")
                                } else {
                                    "checkbox"
                                },
                            );
                            ::sycamore::reactive::create_effect(
                                cx,
                                {
                                    let __el = ::std::clone::Clone::clone(&__el);
                                    move || {
                                        ::sycamore::generic_node::GenericNode::set_attribute(
                                            &__el,
                                            "id",
                                            &::std::string::ToString::to_string(
                                                &{
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("player_{0}_is_ai", props.idx),
                                                    );
                                                    res
                                                },
                                            ),
                                        );
                                    }
                                },
                            );
                            ::sycamore::generic_node::GenericNode::event(
                                &__el,
                                cx,
                                "change",
                                move |e| checkbox_handle(e),
                            );
                            __el
                        },
                    );
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &{
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::label,
                            >();
                            ::sycamore::reactive::create_effect(
                                cx,
                                {
                                    let __el = ::std::clone::Clone::clone(&__el);
                                    move || {
                                        ::sycamore::generic_node::GenericNode::set_attribute(
                                            &__el,
                                            "for",
                                            &::std::string::ToString::to_string(
                                                &{
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("player_{0}_is_ai", props.idx),
                                                    );
                                                    res
                                                },
                                            ),
                                        );
                                    }
                                },
                            );
                            ::sycamore::generic_node::GenericNode::update_inner_text(
                                &__el,
                                "is AI",
                            );
                            __el
                        },
                    );
                    let __comp = {
                        let __component = &Color_Setup;
                        ::sycamore::component::component_scope(move || __component(
                            cx,
                            ::sycamore::component::element_like_component_builder(
                                    __component,
                                )
                                .idx(props.idx)
                                .data(props.data)
                                .done(props.done)
                                .build(),
                        ))
                    };
                    let __initial = ::sycamore::utils::initial_node(&__el);
                    let __marker = ::std::option::Option::None;
                    ::sycamore::utils::render::insert(
                        cx,
                        &__el,
                        __comp,
                        __initial,
                        __marker,
                        true,
                    );
                    __el
                })
            }
        }
        #[allow(non_snake_case)]
        pub fn Color_Setup<'a, G: Html>(
            cx: Scope<'a>,
            props: PlayerConfigProps<'a>,
        ) -> View<G> {
            let onchange_handle = move |e: Event| {
                let select_elem = e
                    .target()
                    .unwrap()
                    .dyn_ref::<HtmlSelectElement>()
                    .unwrap()
                    .clone();
                let is_checked = select_elem.value();
                let idx = props.idx as usize;
                let mut tmp_player_config = (*props.data.get()).clone();
                tmp_player_config.player_colors[idx - 1] = is_checked;
                props.data.set(tmp_player_config);
            };
            let colors = get_colors_array();
            let options = View::new_fragment(
                colors
                    .iter()
                    .map(|&color| {
                        #[allow(unused_variables)]
                        let cx: ::sycamore::reactive::BoundedScope = cx;
                        ::sycamore::view::View::new_node({
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::option,
                            >();
                            ::sycamore::reactive::create_effect(
                                cx,
                                {
                                    let __el = ::std::clone::Clone::clone(&__el);
                                    move || {
                                        ::sycamore::generic_node::GenericNode::set_attribute(
                                            &__el,
                                            "value",
                                            &::std::string::ToString::to_string(&color),
                                        );
                                    }
                                },
                            );
                            ::sycamore::utils::render::insert(
                                cx,
                                &__el,
                                ::sycamore::view::IntoView::create(&(color)),
                                None,
                                None,
                                false,
                            );
                            __el
                        })
                    })
                    .collect(),
            );
            {
                #[allow(unused_variables)]
                let cx: ::sycamore::reactive::BoundedScope = cx;
                ::sycamore::view::View::new_node({
                    let __el = ::sycamore::generic_node::GenericNode::element::<
                        ::sycamore::web::html::select,
                    >();
                    ::sycamore::generic_node::GenericNode::set_class_name(
                        &__el,
                        if false {
                            ::sycamore::rt::intern("form-select")
                        } else {
                            "form-select"
                        },
                    );
                    ::sycamore::generic_node::GenericNode::set_attribute(
                        &__el,
                        "style",
                        if false {
                            ::sycamore::rt::intern("width: fit-content")
                        } else {
                            "width: fit-content"
                        },
                    );
                    ::sycamore::generic_node::GenericNode::event(
                        &__el,
                        cx,
                        "change",
                        move |e| onchange_handle(e),
                    );
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &{
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::option,
                            >();
                            ::sycamore::generic_node::GenericNode::set_attribute(
                                &__el,
                                "value",
                                if false {
                                    ::sycamore::rt::intern("empty")
                                } else {
                                    "empty"
                                },
                            );
                            ::sycamore::generic_node::GenericNode::update_inner_text(
                                &__el,
                                "choose a color",
                            );
                            __el
                        },
                    );
                    ::sycamore::utils::render::insert(
                        cx,
                        &__el,
                        ::sycamore::view::IntoView::create(&(options)),
                        None,
                        None,
                        true,
                    );
                    __el
                })
            }
        }
        pub struct PlayersSetupProps<'a> {
            pub game_ref: &'a Signal<Rc<RefCell<Game>>>,
            pub ui_state: &'a Signal<UiState>,
        }
        impl<'a> ::sycamore::component::Prop for PlayersSetupProps<'a> {
            type Builder = PlayersSetupPropsBuilder<'a, ((), ())>;
            /**
                    Create a builder for building `PlayersSetupProps`.
                    On the builder, call `.game_ref(...)`, `.ui_state(...)` to set the values of the fields.
                    Finally, call `.build()` to create the instance of `PlayersSetupProps`.
                    */
            #[allow(dead_code, clippy::default_trait_access)]
            fn builder() -> Self::Builder {
                PlayersSetupPropsBuilder {
                    fields: ((), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct PlayersSetupPropsBuilder<'a, PropFields> {
            fields: PropFields,
            phantom: (::core::marker::PhantomData<&'a ()>),
        }
        impl<'a, PropFields> Clone for PlayersSetupPropsBuilder<'a, PropFields>
        where
            PropFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait PlayersSetupPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> PlayersSetupPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> PlayersSetupPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, __ui_state> PlayersSetupPropsBuilder<'a, ((), __ui_state)> {
            pub fn game_ref(
                self,
                game_ref: &'a Signal<Rc<RefCell<Game>>>,
            ) -> PlayersSetupPropsBuilder<
                'a,
                ((&'a Signal<Rc<RefCell<Game>>>,), __ui_state),
            > {
                let game_ref = (game_ref,);
                let (_, ui_state) = self.fields;
                PlayersSetupPropsBuilder {
                    fields: (game_ref, ui_state),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayersSetupPropsBuilder_Error_Repeated_field_game_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_state,
        > PlayersSetupPropsBuilder<'a, ((&'a Signal<Rc<RefCell<Game>>>,), __ui_state)> {
            #[deprecated(note = "Repeated field game_ref")]
            pub fn game_ref(
                self,
                _: PlayersSetupPropsBuilder_Error_Repeated_field_game_ref,
            ) -> PlayersSetupPropsBuilder<
                'a,
                ((&'a Signal<Rc<RefCell<Game>>>,), __ui_state),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, __game_ref> PlayersSetupPropsBuilder<'a, (__game_ref, ())> {
            pub fn ui_state(
                self,
                ui_state: &'a Signal<UiState>,
            ) -> PlayersSetupPropsBuilder<'a, (__game_ref, (&'a Signal<UiState>,))> {
                let ui_state = (ui_state,);
                let (game_ref, _) = self.fields;
                PlayersSetupPropsBuilder {
                    fields: (game_ref, ui_state),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayersSetupPropsBuilder_Error_Repeated_field_ui_state {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __game_ref,
        > PlayersSetupPropsBuilder<'a, (__game_ref, (&'a Signal<UiState>,))> {
            #[deprecated(note = "Repeated field ui_state")]
            pub fn ui_state(
                self,
                _: PlayersSetupPropsBuilder_Error_Repeated_field_ui_state,
            ) -> PlayersSetupPropsBuilder<'a, (__game_ref, (&'a Signal<UiState>,))> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayersSetupPropsBuilder_Error_Missing_required_field_game_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<'a, __ui_state> PlayersSetupPropsBuilder<'a, ((), __ui_state)> {
            #[deprecated(note = "Missing required field game_ref")]
            pub fn build(
                self,
                _: PlayersSetupPropsBuilder_Error_Missing_required_field_game_ref,
            ) -> PlayersSetupProps<'a> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PlayersSetupPropsBuilder_Error_Missing_required_field_ui_state {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<'a> PlayersSetupPropsBuilder<'a, ((&'a Signal<Rc<RefCell<Game>>>,), ())> {
            #[deprecated(note = "Missing required field ui_state")]
            pub fn build(
                self,
                _: PlayersSetupPropsBuilder_Error_Missing_required_field_ui_state,
            ) -> PlayersSetupProps<'a> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
        > PlayersSetupPropsBuilder<
            'a,
            ((&'a Signal<Rc<RefCell<Game>>>,), (&'a Signal<UiState>,)),
        > {
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> PlayersSetupProps<'a> {
                let (game_ref, ui_state) = self.fields;
                let game_ref = game_ref.0;
                let ui_state = ui_state.0;
                PlayersSetupProps {
                    game_ref,
                    ui_state,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for PlayersSetupProps<'a> {
            #[inline]
            fn clone(&self) -> PlayersSetupProps<'a> {
                PlayersSetupProps {
                    game_ref: ::core::clone::Clone::clone(&self.game_ref),
                    ui_state: ::core::clone::Clone::clone(&self.ui_state),
                }
            }
        }
        #[allow(non_snake_case)]
        pub fn PlayersSetup<'a, G: Html>(
            cx: Scope<'a>,
            props: PlayersSetupProps<'a>,
        ) -> View<G> {
            let max_players = 6i32;
            let min_players = 2i32;
            let next_sig = create_signal(cx, true);
            let done_sig: &Signal<bool> = create_signal(cx, false);
            let player_config_sig: &Signal<PlayerConfig> = create_signal(
                cx,
                PlayerConfig::new(),
            );
            let error_msg_sig: &Signal<String> = create_signal(cx, "".to_string());
            let next = move || {
                let mut tmp_player_config = (*player_config_sig.get()).clone();
                if *next_sig.get() == true {
                    let player_count = &(*player_config_sig.get()).player_count;
                    while tmp_player_config.player_colors.len() < *player_count as usize
                    {
                        tmp_player_config.player_colors.push("empty".to_string());
                    }
                    while tmp_player_config.player_is_ai.len() < *player_count as usize {
                        tmp_player_config.player_is_ai.push(false);
                    }
                    player_config_sig.set(tmp_player_config);
                    next_sig.set(!*next_sig.get());
                } else {
                    let mut validated = true;
                    let mut _return = false;
                    for color in &tmp_player_config.player_colors {
                        if color == "empty" {
                            validated = false;
                            break;
                        }
                    }
                    if !validated {
                        if !_return {
                            error_msg_sig
                                .set("All color fields have a color".to_string());
                            _return = true;
                        }
                    } else {
                        let mut found: Vec<String> = Vec::new();
                        for color in &tmp_player_config.player_colors {
                            if !found.contains(color) {
                                found.push(color.clone());
                            } else {
                                validated = false;
                                break;
                            }
                        }
                    }
                    if !validated {
                        if !_return {
                            error_msg_sig
                                .set("All players must have diiferent colors".to_string());
                            _return = true;
                        }
                    } else {
                        (*props.game_ref.get())
                            .borrow_mut()
                            .set_player_config(tmp_player_config);
                        props.ui_state.set(UiState::ARMY_PLACEMENT_START);
                    }
                }
            };
            let player_options = View::new_fragment(
                (min_players..max_players + 1)
                    .map(|x| {
                        #[allow(unused_variables)]
                        let cx: ::sycamore::reactive::BoundedScope = cx;
                        ::sycamore::view::View::new_node({
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::option,
                            >();
                            ::sycamore::reactive::create_effect(
                                cx,
                                {
                                    let __el = ::std::clone::Clone::clone(&__el);
                                    move || {
                                        ::sycamore::generic_node::GenericNode::set_attribute(
                                            &__el,
                                            "value",
                                            &::std::string::ToString::to_string(&x),
                                        );
                                    }
                                },
                            );
                            ::sycamore::generic_node::GenericNode::event(
                                &__el,
                                cx,
                                "click",
                                move |_| {
                                    let mut tmp_player_config = (*player_config_sig.get())
                                        .clone();
                                    tmp_player_config.player_count = x;
                                    player_config_sig.set(tmp_player_config);
                                },
                            );
                            ::sycamore::utils::render::insert(
                                cx,
                                &__el,
                                ::sycamore::view::IntoView::create(&(x)),
                                None,
                                None,
                                false,
                            );
                            __el
                        })
                    })
                    .collect(),
            );
            let player_config_iter_sig = create_memo(
                cx,
                move || {
                    let ret: Vec<i32> = (1..(*player_config_sig.get()).player_count + 1)
                        .collect();
                    ret
                },
            );
            {
                #[allow(unused_variables)]
                let cx: ::sycamore::reactive::BoundedScope = cx;
                ::sycamore::view::View::new_node({
                    let __el = ::sycamore::generic_node::GenericNode::element::<
                        ::sycamore::web::html::div,
                    >();
                    let __view = ::sycamore::view::View::new_dyn_scoped(
                        cx,
                        move |cx| ::sycamore::view::IntoView::create(
                            &(if *next_sig.get() {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    ::sycamore::view::View::new_node({
                                        let __el = ::sycamore::generic_node::GenericNode::element::<
                                            ::sycamore::web::html::select,
                                        >();
                                        ::sycamore::generic_node::GenericNode::set_class_name(
                                            &__el,
                                            if false {
                                                ::sycamore::rt::intern("form-select")
                                            } else {
                                                "form-select"
                                            },
                                        );
                                        ::sycamore::generic_node::GenericNode::set_attribute(
                                            &__el,
                                            "style",
                                            if false {
                                                ::sycamore::rt::intern("width: fit-content")
                                            } else {
                                                "width: fit-content"
                                            },
                                        );
                                        ::sycamore::generic_node::GenericNode::append_child(
                                            &__el,
                                            &{
                                                let __el = ::sycamore::generic_node::GenericNode::element::<
                                                    ::sycamore::web::html::option,
                                                >();
                                                ::sycamore::generic_node::GenericNode::update_inner_text(
                                                    &__el,
                                                    "Choose the number of players",
                                                );
                                                __el
                                            },
                                        );
                                        ::sycamore::utils::render::insert(
                                            cx,
                                            &__el,
                                            ::sycamore::view::IntoView::create(&(player_options)),
                                            None,
                                            None,
                                            true,
                                        );
                                        __el
                                    })
                                }
                            } else {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    {
                                        let __component = &Keyed;
                                        ::sycamore::component::component_scope(move || __component(
                                            cx,
                                            ::sycamore::component::element_like_component_builder(
                                                    __component,
                                                )
                                                .iterable(player_config_iter_sig)
                                                .key(|x| *x)
                                                .view(move |cx, x| {
                                                    #[allow(unused_variables)]
                                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                                    ::sycamore::view::View::new_node({
                                                        let __el = ::sycamore::generic_node::GenericNode::element::<
                                                            ::sycamore::web::html::div,
                                                        >();
                                                        let __comp = {
                                                            let __component = &PlayerSetup;
                                                            ::sycamore::component::component_scope(move || __component(
                                                                cx,
                                                                ::sycamore::component::element_like_component_builder(
                                                                        __component,
                                                                    )
                                                                    .idx(x)
                                                                    .data(player_config_sig)
                                                                    .done(done_sig)
                                                                    .build(),
                                                            ))
                                                        };
                                                        let __initial = ::sycamore::utils::initial_node(&__el);
                                                        let __marker = ::std::option::Option::None;
                                                        ::sycamore::utils::render::insert(
                                                            cx,
                                                            &__el,
                                                            __comp,
                                                            __initial,
                                                            __marker,
                                                            false,
                                                        );
                                                        __el
                                                    })
                                                })
                                                .build(),
                                        ))
                                    }
                                }
                            }),
                        ),
                    );
                    let __initial = ::sycamore::utils::initial_node(&__el);
                    let __marker = {
                        let __el = ::sycamore::generic_node::GenericNode::element::<
                            ::sycamore::web::html::button,
                        >();
                        ::sycamore::generic_node::GenericNode::set_attribute(
                            &__el,
                            "id",
                            if false { ::sycamore::rt::intern("run") } else { "run" },
                        );
                        ::sycamore::generic_node::GenericNode::set_attribute(
                            &__el,
                            "type",
                            if false {
                                ::sycamore::rt::intern("button")
                            } else {
                                "button"
                            },
                        );
                        ::sycamore::generic_node::GenericNode::set_class_name(
                            &__el,
                            if false {
                                ::sycamore::rt::intern("btn btn-primary")
                            } else {
                                "btn btn-primary"
                            },
                        );
                        ::sycamore::generic_node::GenericNode::event(
                            &__el,
                            cx,
                            "click",
                            move |_| next(),
                        );
                        ::sycamore::generic_node::GenericNode::update_inner_text(
                            &__el,
                            "Next",
                        );
                        __el
                    };
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &__marker,
                    );
                    let __marker = ::std::option::Option::Some(&__marker);
                    ::sycamore::utils::render::insert(
                        cx,
                        &__el,
                        __view,
                        __initial,
                        __marker,
                        true,
                    );
                    ::sycamore::generic_node::GenericNode::append_child(
                        &__el,
                        &{
                            let __el = ::sycamore::generic_node::GenericNode::element::<
                                ::sycamore::web::html::label,
                            >();
                            let __view = ::sycamore::view::View::new_dyn(
                                cx,
                                move || ::sycamore::view::IntoView::create(
                                    &(*error_msg_sig.get()),
                                ),
                            );
                            let __initial = ::sycamore::utils::initial_node(&__el);
                            let __marker = ::std::option::Option::None;
                            ::sycamore::utils::render::insert(
                                cx,
                                &__el,
                                __view,
                                __initial,
                                __marker,
                                false,
                            );
                            __el
                        },
                    );
                    __el
                })
            }
        }
    }
    pub mod main {
        use std::cell::RefCell;
        use sycamore::prelude::*;
        use std::rc::Rc;
        use gloo::console::log;
        use crate::game::Game;
        use crate::ui::player_setup::*;
        use crate::ui::structs::{ArmyPlacementInfo, StartArmyPlacementInfo, UiUpdatable};
        #[allow(non_camel_case_types)]
        pub enum UiState {
            SETUP,
            ARMY_PLACEMENT_START,
            ARMY_PLACEMENT,
            TURN_START,
            TURN,
            COMBAT,
            GAME_END,
            CARD_SELECT,
        }
        #[allow(non_camel_case_types)]
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UiState {}
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::cmp::PartialEq for UiState {
            #[inline]
            fn eq(&self, other: &UiState) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::marker::Copy for UiState {}
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UiState {
            #[inline]
            fn clone(&self) -> UiState {
                *self
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::fmt::Debug for UiState {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        UiState::SETUP => "SETUP",
                        UiState::ARMY_PLACEMENT_START => "ARMY_PLACEMENT_START",
                        UiState::ARMY_PLACEMENT => "ARMY_PLACEMENT",
                        UiState::TURN_START => "TURN_START",
                        UiState::TURN => "TURN",
                        UiState::COMBAT => "COMBAT",
                        UiState::GAME_END => "GAME_END",
                        UiState::CARD_SELECT => "CARD_SELECT",
                    },
                )
            }
        }
        pub struct UiMainProps {
            pub game_ref: Rc<RefCell<Game>>,
        }
        impl ::sycamore::component::Prop for UiMainProps {
            type Builder = UiMainPropsBuilder<((),)>;
            /**
                    Create a builder for building `UiMainProps`.
                    On the builder, call `.game_ref(...)` to set the values of the fields.
                    Finally, call `.build()` to create the instance of `UiMainProps`.
                    */
            #[allow(dead_code, clippy::default_trait_access)]
            fn builder() -> Self::Builder {
                UiMainPropsBuilder {
                    fields: ((),),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct UiMainPropsBuilder<PropFields> {
            fields: PropFields,
            phantom: (),
        }
        impl<PropFields> Clone for UiMainPropsBuilder<PropFields>
        where
            PropFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait UiMainPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> UiMainPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> UiMainPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl UiMainPropsBuilder<((),)> {
            pub fn game_ref(
                self,
                game_ref: Rc<RefCell<Game>>,
            ) -> UiMainPropsBuilder<((Rc<RefCell<Game>>,),)> {
                let game_ref = (game_ref,);
                let (_,) = self.fields;
                UiMainPropsBuilder {
                    fields: (game_ref,),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum UiMainPropsBuilder_Error_Repeated_field_game_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl UiMainPropsBuilder<((Rc<RefCell<Game>>,),)> {
            #[deprecated(note = "Repeated field game_ref")]
            pub fn game_ref(
                self,
                _: UiMainPropsBuilder_Error_Repeated_field_game_ref,
            ) -> UiMainPropsBuilder<((Rc<RefCell<Game>>,),)> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum UiMainPropsBuilder_Error_Missing_required_field_game_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl UiMainPropsBuilder<((),)> {
            #[deprecated(note = "Missing required field game_ref")]
            pub fn build(
                self,
                _: UiMainPropsBuilder_Error_Missing_required_field_game_ref,
            ) -> UiMainProps {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl UiMainPropsBuilder<((Rc<RefCell<Game>>,),)> {
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> UiMainProps {
                let (game_ref,) = self.fields;
                let game_ref = game_ref.0;
                UiMainProps { game_ref }
            }
        }
        #[allow(non_snake_case)]
        pub fn UiSide<G: Html>(cx: Scope, props: UiMainProps) -> View<G> {
            let ui_info_struct = props.game_ref.borrow().get_ui_info_clone();
            let info_placement_rc = ui_info_struct.placement.clone();
            let info_placement_start_rc = ui_info_struct.start_placement.clone();
            let ui_state_rc = ui_info_struct.ui_state.clone();
            let ui_state: &Signal<UiState> = create_signal(cx, UiState::SETUP);
            let arg_ref = create_signal(cx, props.game_ref.clone());
            let army_placement_sig = create_signal(
                cx,
                *ui_info_struct.placement.get().clone(),
            );
            let army_placement_start_sig = create_signal(
                cx,
                *ui_info_struct.start_placement.get().clone(),
            );
            let _ = create_memo(
                cx,
                move || {
                    if *info_placement_rc.get() != *army_placement_sig.get() {
                        if army_placement_sig.get().updated {
                            let mut tmp = *army_placement_sig.get();
                            tmp.updated = false;
                            info_placement_rc.set(tmp.clone());
                            army_placement_sig.set(tmp);
                        } else {
                            let mut tmp = *info_placement_rc.get();
                            tmp.updated = false;
                            army_placement_sig.set(tmp.clone());
                            info_placement_rc.set(tmp);
                        }
                    }
                },
            );
            let _ = create_memo(
                cx,
                move || {
                    ::gloo_console::externs::log(
                        ::std::boxed::Box::from([
                            ::gloo_console::__macro::JsValue::from("checking eq"),
                        ]),
                    );
                    if *info_placement_start_rc.get() != *army_placement_start_sig.get()
                    {
                        let mut tmp = if army_placement_start_sig.get().updated {
                            ::gloo_console::externs::log(
                                ::std::boxed::Box::from([
                                    ::gloo_console::__macro::JsValue::from(
                                        "updating placement start from sig",
                                    ),
                                ]),
                            );
                            *army_placement_start_sig.get()
                        } else {
                            ::gloo_console::externs::log(
                                ::std::boxed::Box::from([
                                    ::gloo_console::__macro::JsValue::from(
                                        "updating placement start from rc",
                                    ),
                                ]),
                            );
                            *info_placement_start_rc.get()
                        };
                        tmp.updated = false;
                        info_placement_start_rc.set(tmp.clone());
                        army_placement_start_sig.set(tmp);
                        army_placement_start_sig.trigger_subscribers();
                    } else {
                        ::gloo_console::externs::log(
                            ::std::boxed::Box::from([
                                ::gloo_console::__macro::JsValue::from("no diff"),
                            ]),
                        )
                    }
                },
            );
            let _ = create_memo(
                cx,
                move || {
                    if *ui_state_rc.get() != *ui_state.get() {
                        ui_state_rc.set(*ui_state.get());
                    }
                },
            );
            {
                #[allow(unused_variables)]
                let cx: ::sycamore::reactive::BoundedScope = cx;
                ::sycamore::view::View::new_node({
                    let __el = ::sycamore::generic_node::GenericNode::element::<
                        ::sycamore::web::html::div,
                    >();
                    let __view = ::sycamore::view::View::new_dyn_scoped(
                        cx,
                        move |cx| ::sycamore::view::IntoView::create(
                            &(if *ui_state.get() == UiState::SETUP {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    {
                                        let __component = &PlayersSetup;
                                        ::sycamore::component::component_scope(move || __component(
                                            cx,
                                            ::sycamore::component::element_like_component_builder(
                                                    __component,
                                                )
                                                .game_ref(arg_ref)
                                                .ui_state(ui_state)
                                                .build(),
                                        ))
                                    }
                                }
                            } else if *ui_state.get() == UiState::ARMY_PLACEMENT_START {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    {
                                        let __component = &ArmyPlacementStart;
                                        ::sycamore::component::component_scope(move || __component(
                                            cx,
                                            ::sycamore::component::element_like_component_builder(
                                                    __component,
                                                )
                                                .ui_state(ui_state)
                                                .ui_info(army_placement_start_sig)
                                                .build(),
                                        ))
                                    }
                                }
                            } else if *ui_state.get() == UiState::ARMY_PLACEMENT {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    {
                                        let __component = &Turn_Ui;
                                        ::sycamore::component::component_scope(move || __component(
                                            cx,
                                            ::sycamore::component::element_like_component_builder(
                                                    __component,
                                                )
                                                .army_num(9u32)
                                                .player_id(1u32)
                                                .ui_state(ui_state)
                                                .ui_info(army_placement_sig)
                                                .build(),
                                        ))
                                    }
                                }
                            } else if *ui_state.get() == UiState::GAME_END {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    ::sycamore::view::View::new_node({
                                        let __el = ::sycamore::generic_node::GenericNode::element::<
                                            ::sycamore::web::html::div,
                                        >();
                                        ::sycamore::generic_node::GenericNode::update_inner_text(
                                            &__el,
                                            "game end",
                                        );
                                        __el
                                    })
                                }
                            } else {
                                {
                                    #[allow(unused_variables)]
                                    let cx: ::sycamore::reactive::BoundedScope = cx;
                                    ::sycamore::view::View::new_node({
                                        let __el = ::sycamore::generic_node::GenericNode::element::<
                                            ::sycamore::web::html::div,
                                        >();
                                        ::sycamore::generic_node::GenericNode::update_inner_text(
                                            &__el,
                                            "default ui state",
                                        );
                                        __el
                                    })
                                }
                            }),
                        ),
                    );
                    let __initial = ::sycamore::utils::initial_node(&__el);
                    let __marker = ::std::option::Option::None;
                    ::sycamore::utils::render::insert(
                        cx,
                        &__el,
                        __view,
                        __initial,
                        __marker,
                        false,
                    );
                    __el
                })
            }
        }
        #[allow(non_camel_case_types)]
        ///Props for [`Turn_Ui`].
        pub struct Turn_Ui_Props<'a, G: Html> {
            army_num: u32,
            player_id: u32,
            ui_state: &'a Signal<UiState>,
            ui_info: &'a Signal<ArmyPlacementInfo>,
            #[builder(default, setter(skip))]
            __phantom0: ::std::marker::PhantomData<&'a ()>,
            #[builder(default, setter(skip))]
            __phantom1: ::std::marker::PhantomData<G>,
        }
        impl<'a, G: Html> ::sycamore::component::Prop for Turn_Ui_Props<'a, G> {
            type Builder = Turn_Ui_PropsBuilder<'a, ((), (), (), ()), G>;
            /**
                    Create a builder for building `Turn_Ui_Props`.
                    On the builder, call `.army_num(...)`, `.player_id(...)`, `.ui_state(...)`, `.ui_info(...)` to set the values of the fields.
                    Finally, call `.build()` to create the instance of `Turn_Ui_Props`.
                    */
            #[allow(dead_code, clippy::default_trait_access)]
            fn builder() -> Self::Builder {
                Turn_Ui_PropsBuilder {
                    fields: ((), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct Turn_Ui_PropsBuilder<'a, PropFields, G: Html> {
            fields: PropFields,
            phantom: (
                ::core::marker::PhantomData<&'a ()>,
                ::core::marker::PhantomData<G>,
            ),
        }
        impl<'a, PropFields, G: Html> Clone for Turn_Ui_PropsBuilder<'a, PropFields, G>
        where
            PropFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait Turn_Ui_PropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> Turn_Ui_PropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> Turn_Ui_PropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            __ui_state,
            __player_id,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, ((), __player_id, __ui_state, __ui_info), G> {
            pub fn army_num(
                self,
                army_num: u32,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                ((u32,), __player_id, __ui_state, __ui_info),
                G,
            > {
                let army_num = (army_num,);
                let (_, player_id, ui_state, ui_info) = self.fields;
                Turn_Ui_PropsBuilder {
                    fields: (army_num, player_id, ui_state, ui_info),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Repeated_field_army_num {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            __ui_state,
            __player_id,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, ((u32,), __player_id, __ui_state, __ui_info), G> {
            #[deprecated(note = "Repeated field army_num")]
            pub fn army_num(
                self,
                _: Turn_Ui_PropsBuilder_Error_Repeated_field_army_num,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                ((u32,), __player_id, __ui_state, __ui_info),
                G,
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            __ui_state,
            __army_num,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, (__army_num, (), __ui_state, __ui_info), G> {
            pub fn player_id(
                self,
                player_id: u32,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                (__army_num, (u32,), __ui_state, __ui_info),
                G,
            > {
                let player_id = (player_id,);
                let (army_num, _, ui_state, ui_info) = self.fields;
                Turn_Ui_PropsBuilder {
                    fields: (army_num, player_id, ui_state, ui_info),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Repeated_field_player_id {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            __ui_state,
            __army_num,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, (__army_num, (u32,), __ui_state, __ui_info), G> {
            #[deprecated(note = "Repeated field player_id")]
            pub fn player_id(
                self,
                _: Turn_Ui_PropsBuilder_Error_Repeated_field_player_id,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                (__army_num, (u32,), __ui_state, __ui_info),
                G,
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            __player_id,
            __army_num,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, (__army_num, __player_id, (), __ui_info), G> {
            pub fn ui_state(
                self,
                ui_state: &'a Signal<UiState>,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                (__army_num, __player_id, (&'a Signal<UiState>,), __ui_info),
                G,
            > {
                let ui_state = (ui_state,);
                let (army_num, player_id, _, ui_info) = self.fields;
                Turn_Ui_PropsBuilder {
                    fields: (army_num, player_id, ui_state, ui_info),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Repeated_field_ui_state {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            __player_id,
            __army_num,
            G: Html,
        > Turn_Ui_PropsBuilder<
            'a,
            (__army_num, __player_id, (&'a Signal<UiState>,), __ui_info),
            G,
        > {
            #[deprecated(note = "Repeated field ui_state")]
            pub fn ui_state(
                self,
                _: Turn_Ui_PropsBuilder_Error_Repeated_field_ui_state,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                (__army_num, __player_id, (&'a Signal<UiState>,), __ui_info),
                G,
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_state,
            __player_id,
            __army_num,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, (__army_num, __player_id, __ui_state, ()), G> {
            pub fn ui_info(
                self,
                ui_info: &'a Signal<ArmyPlacementInfo>,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                (__army_num, __player_id, __ui_state, (&'a Signal<ArmyPlacementInfo>,)),
                G,
            > {
                let ui_info = (ui_info,);
                let (army_num, player_id, ui_state, _) = self.fields;
                Turn_Ui_PropsBuilder {
                    fields: (army_num, player_id, ui_state, ui_info),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Repeated_field_ui_info {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_state,
            __player_id,
            __army_num,
            G: Html,
        > Turn_Ui_PropsBuilder<
            'a,
            (__army_num, __player_id, __ui_state, (&'a Signal<ArmyPlacementInfo>,)),
            G,
        > {
            #[deprecated(note = "Repeated field ui_info")]
            pub fn ui_info(
                self,
                _: Turn_Ui_PropsBuilder_Error_Repeated_field_ui_info,
            ) -> Turn_Ui_PropsBuilder<
                'a,
                (__army_num, __player_id, __ui_state, (&'a Signal<ArmyPlacementInfo>,)),
                G,
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Missing_required_field_army_num {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
            __ui_info,
            __ui_state,
            __player_id,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, ((), __player_id, __ui_state, __ui_info), G> {
            #[deprecated(note = "Missing required field army_num")]
            pub fn build(
                self,
                _: Turn_Ui_PropsBuilder_Error_Missing_required_field_army_num,
            ) -> Turn_Ui_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Missing_required_field_player_id {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
            __ui_info,
            __ui_state,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, ((u32,), (), __ui_state, __ui_info), G> {
            #[deprecated(note = "Missing required field player_id")]
            pub fn build(
                self,
                _: Turn_Ui_PropsBuilder_Error_Missing_required_field_player_id,
            ) -> Turn_Ui_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Missing_required_field_ui_state {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
            __ui_info,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, ((u32,), (u32,), (), __ui_info), G> {
            #[deprecated(note = "Missing required field ui_state")]
            pub fn build(
                self,
                _: Turn_Ui_PropsBuilder_Error_Missing_required_field_ui_state,
            ) -> Turn_Ui_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum Turn_Ui_PropsBuilder_Error_Missing_required_field_ui_info {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
            G: Html,
        > Turn_Ui_PropsBuilder<'a, ((u32,), (u32,), (&'a Signal<UiState>,), ()), G> {
            #[deprecated(note = "Missing required field ui_info")]
            pub fn build(
                self,
                _: Turn_Ui_PropsBuilder_Error_Missing_required_field_ui_info,
            ) -> Turn_Ui_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            G: Html,
        > Turn_Ui_PropsBuilder<
            'a,
            ((u32,), (u32,), (&'a Signal<UiState>,), (&'a Signal<ArmyPlacementInfo>,)),
            G,
        > {
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> Turn_Ui_Props<'a, G> {
                let (army_num, player_id, ui_state, ui_info) = self.fields;
                let army_num = army_num.0;
                let player_id = player_id.0;
                let ui_state = ui_state.0;
                let ui_info = ui_info.0;
                let __phantom0 = ::core::default::Default::default();
                let __phantom1 = ::core::default::Default::default();
                Turn_Ui_Props {
                    army_num,
                    player_id,
                    ui_state,
                    ui_info,
                    __phantom0,
                    __phantom1,
                }
            }
        }
        #[allow(non_snake_case)]
        pub fn Turn_Ui<'a, G: Html>(
            cx: Scope<'a>,
            __props: Turn_Ui_Props<'a, G>,
        ) -> View<G> {
            let Turn_Ui_Props { army_num, player_id, ui_state, ui_info, .. } = __props;
            {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from("running setup"),
                    ]),
                );
                ui_info
                    .set(
                        ui_info
                            .get()
                            .update(|tmp| {
                                tmp.army_count = army_num;
                                tmp.current_player = player_id;
                            }),
                    );
                let _ = create_memo(
                    cx,
                    move || {
                        let tmp = *ui_info.get();
                        if tmp.army_count == 0 {
                            ui_state.set(UiState::GAME_END);
                        }
                    },
                );
                {
                    #[allow(unused_variables)]
                    let cx: ::sycamore::reactive::BoundedScope = cx;
                    ::sycamore::view::View::new_fragment({
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::div,
                                    >();
                                    ::sycamore::generic_node::GenericNode::update_inner_text(
                                        &__el,
                                        "turn test",
                                    );
                                    __el
                                }),
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::h1,
                                    >();
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &::sycamore::generic_node::GenericNode::text_node("Player "),
                                    );
                                    let __view = ::sycamore::view::View::new_dyn(
                                        cx,
                                        move || ::sycamore::view::IntoView::create(
                                            &(ui_info.get().current_player + 1),
                                        ),
                                    );
                                    let __initial = ::sycamore::utils::initial_node(&__el);
                                    let __marker = ::std::option::Option::None;
                                    ::sycamore::utils::render::insert(
                                        cx,
                                        &__el,
                                        __view,
                                        __initial,
                                        __marker,
                                        true,
                                    );
                                    __el
                                }),
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::div,
                                    >();
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &::sycamore::generic_node::GenericNode::text_node(
                                            "You still have ",
                                        ),
                                    );
                                    let __view = ::sycamore::view::View::new_dyn(
                                        cx,
                                        move || ::sycamore::view::IntoView::create(
                                            &(ui_info.get().army_count),
                                        ),
                                    );
                                    let __initial = ::sycamore::utils::initial_node(&__el);
                                    let __marker = ::sycamore::generic_node::GenericNode::text_node(
                                        " armies to place",
                                    );
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &__marker,
                                    );
                                    let __marker = ::std::option::Option::Some(&__marker);
                                    ::sycamore::utils::render::insert(
                                        cx,
                                        &__el,
                                        __view,
                                        __initial,
                                        __marker,
                                        true,
                                    );
                                    __el
                                }),
                            ]),
                        )
                    })
                }
            }
        }
        #[allow(non_camel_case_types)]
        ///Props for [`ArmyPlacementUi`].
        pub struct ArmyPlacementUi_Props<'a, G: Html> {
            ui_info: &'a Signal<ArmyPlacementInfo>,
            #[builder(default, setter(skip))]
            __phantom0: ::std::marker::PhantomData<&'a ()>,
            #[builder(default, setter(skip))]
            __phantom1: ::std::marker::PhantomData<G>,
        }
        impl<'a, G: Html> ::sycamore::component::Prop for ArmyPlacementUi_Props<'a, G> {
            type Builder = ArmyPlacementUi_PropsBuilder<'a, ((),), G>;
            /**
                    Create a builder for building `ArmyPlacementUi_Props`.
                    On the builder, call `.ui_info(...)` to set the values of the fields.
                    Finally, call `.build()` to create the instance of `ArmyPlacementUi_Props`.
                    */
            #[allow(dead_code, clippy::default_trait_access)]
            fn builder() -> Self::Builder {
                ArmyPlacementUi_PropsBuilder {
                    fields: ((),),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct ArmyPlacementUi_PropsBuilder<'a, PropFields, G: Html> {
            fields: PropFields,
            phantom: (
                ::core::marker::PhantomData<&'a ()>,
                ::core::marker::PhantomData<G>,
            ),
        }
        impl<'a, PropFields, G: Html> Clone
        for ArmyPlacementUi_PropsBuilder<'a, PropFields, G>
        where
            PropFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait ArmyPlacementUi_PropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> ArmyPlacementUi_PropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> ArmyPlacementUi_PropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<'a, G: Html> ArmyPlacementUi_PropsBuilder<'a, ((),), G> {
            pub fn ui_info(
                self,
                ui_info: &'a Signal<ArmyPlacementInfo>,
            ) -> ArmyPlacementUi_PropsBuilder<
                'a,
                ((&'a Signal<ArmyPlacementInfo>,),),
                G,
            > {
                let ui_info = (ui_info,);
                let (_,) = self.fields;
                ArmyPlacementUi_PropsBuilder {
                    fields: (ui_info,),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum ArmyPlacementUi_PropsBuilder_Error_Repeated_field_ui_info {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            G: Html,
        > ArmyPlacementUi_PropsBuilder<'a, ((&'a Signal<ArmyPlacementInfo>,),), G> {
            #[deprecated(note = "Repeated field ui_info")]
            pub fn ui_info(
                self,
                _: ArmyPlacementUi_PropsBuilder_Error_Repeated_field_ui_info,
            ) -> ArmyPlacementUi_PropsBuilder<
                'a,
                ((&'a Signal<ArmyPlacementInfo>,),),
                G,
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum ArmyPlacementUi_PropsBuilder_Error_Missing_required_field_ui_info {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<'a, G: Html> ArmyPlacementUi_PropsBuilder<'a, ((),), G> {
            #[deprecated(note = "Missing required field ui_info")]
            pub fn build(
                self,
                _: ArmyPlacementUi_PropsBuilder_Error_Missing_required_field_ui_info,
            ) -> ArmyPlacementUi_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            G: Html,
        > ArmyPlacementUi_PropsBuilder<'a, ((&'a Signal<ArmyPlacementInfo>,),), G> {
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> ArmyPlacementUi_Props<'a, G> {
                let (ui_info,) = self.fields;
                let ui_info = ui_info.0;
                let __phantom0 = ::core::default::Default::default();
                let __phantom1 = ::core::default::Default::default();
                ArmyPlacementUi_Props {
                    ui_info,
                    __phantom0,
                    __phantom1,
                }
            }
        }
        #[allow(non_snake_case)]
        pub fn ArmyPlacementUi<'a, G: Html>(
            cx: Scope<'a>,
            __props: ArmyPlacementUi_Props<'a, G>,
        ) -> View<G> {
            let ArmyPlacementUi_Props { ui_info, .. } = __props;
            {
                {
                    #[allow(unused_variables)]
                    let cx: ::sycamore::reactive::BoundedScope = cx;
                    ::sycamore::view::View::new_fragment({
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::h1,
                                    >();
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &::sycamore::generic_node::GenericNode::text_node("Player "),
                                    );
                                    let __view = ::sycamore::view::View::new_dyn(
                                        cx,
                                        move || ::sycamore::view::IntoView::create(
                                            &(ui_info.get().current_player + 1),
                                        ),
                                    );
                                    let __initial = ::sycamore::utils::initial_node(&__el);
                                    let __marker = ::std::option::Option::None;
                                    ::sycamore::utils::render::insert(
                                        cx,
                                        &__el,
                                        __view,
                                        __initial,
                                        __marker,
                                        true,
                                    );
                                    __el
                                }),
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::div,
                                    >();
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &::sycamore::generic_node::GenericNode::text_node(
                                            "You still have ",
                                        ),
                                    );
                                    let __view = ::sycamore::view::View::new_dyn(
                                        cx,
                                        move || ::sycamore::view::IntoView::create(
                                            &(ui_info.get().army_count),
                                        ),
                                    );
                                    let __initial = ::sycamore::utils::initial_node(&__el);
                                    let __marker = ::sycamore::generic_node::GenericNode::text_node(
                                        " armies to place",
                                    );
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &__marker,
                                    );
                                    let __marker = ::std::option::Option::Some(&__marker);
                                    ::sycamore::utils::render::insert(
                                        cx,
                                        &__el,
                                        __view,
                                        __initial,
                                        __marker,
                                        true,
                                    );
                                    __el
                                }),
                            ]),
                        )
                    })
                }
            }
        }
        #[allow(non_camel_case_types)]
        ///Props for [`ArmyPlacementStart`].
        pub struct ArmyPlacementStart_Props<'a, G: Html> {
            ui_state: &'a Signal<UiState>,
            ui_info: &'a Signal<StartArmyPlacementInfo>,
            #[builder(default, setter(skip))]
            __phantom0: ::std::marker::PhantomData<&'a ()>,
            #[builder(default, setter(skip))]
            __phantom1: ::std::marker::PhantomData<G>,
        }
        impl<'a, G: Html> ::sycamore::component::Prop
        for ArmyPlacementStart_Props<'a, G> {
            type Builder = ArmyPlacementStart_PropsBuilder<'a, ((), ()), G>;
            /**
                    Create a builder for building `ArmyPlacementStart_Props`.
                    On the builder, call `.ui_state(...)`, `.ui_info(...)` to set the values of the fields.
                    Finally, call `.build()` to create the instance of `ArmyPlacementStart_Props`.
                    */
            #[allow(dead_code, clippy::default_trait_access)]
            fn builder() -> Self::Builder {
                ArmyPlacementStart_PropsBuilder {
                    fields: ((), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct ArmyPlacementStart_PropsBuilder<'a, PropFields, G: Html> {
            fields: PropFields,
            phantom: (
                ::core::marker::PhantomData<&'a ()>,
                ::core::marker::PhantomData<G>,
            ),
        }
        impl<'a, PropFields, G: Html> Clone
        for ArmyPlacementStart_PropsBuilder<'a, PropFields, G>
        where
            PropFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait ArmyPlacementStart_PropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> ArmyPlacementStart_PropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> ArmyPlacementStart_PropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<'a, ((), __ui_info), G> {
            pub fn ui_state(
                self,
                ui_state: &'a Signal<UiState>,
            ) -> ArmyPlacementStart_PropsBuilder<
                'a,
                ((&'a Signal<UiState>,), __ui_info),
                G,
            > {
                let ui_state = (ui_state,);
                let (_, ui_info) = self.fields;
                ArmyPlacementStart_PropsBuilder {
                    fields: (ui_state, ui_info),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum ArmyPlacementStart_PropsBuilder_Error_Repeated_field_ui_state {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_info,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<'a, ((&'a Signal<UiState>,), __ui_info), G> {
            #[deprecated(note = "Repeated field ui_state")]
            pub fn ui_state(
                self,
                _: ArmyPlacementStart_PropsBuilder_Error_Repeated_field_ui_state,
            ) -> ArmyPlacementStart_PropsBuilder<
                'a,
                ((&'a Signal<UiState>,), __ui_info),
                G,
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_state,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<'a, (__ui_state, ()), G> {
            pub fn ui_info(
                self,
                ui_info: &'a Signal<StartArmyPlacementInfo>,
            ) -> ArmyPlacementStart_PropsBuilder<
                'a,
                (__ui_state, (&'a Signal<StartArmyPlacementInfo>,)),
                G,
            > {
                let ui_info = (ui_info,);
                let (ui_state, _) = self.fields;
                ArmyPlacementStart_PropsBuilder {
                    fields: (ui_state, ui_info),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum ArmyPlacementStart_PropsBuilder_Error_Repeated_field_ui_info {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            __ui_state,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<
            'a,
            (__ui_state, (&'a Signal<StartArmyPlacementInfo>,)),
            G,
        > {
            #[deprecated(note = "Repeated field ui_info")]
            pub fn ui_info(
                self,
                _: ArmyPlacementStart_PropsBuilder_Error_Repeated_field_ui_info,
            ) -> ArmyPlacementStart_PropsBuilder<
                'a,
                (__ui_state, (&'a Signal<StartArmyPlacementInfo>,)),
                G,
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum ArmyPlacementStart_PropsBuilder_Error_Missing_required_field_ui_state {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
            __ui_info,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<'a, ((), __ui_info), G> {
            #[deprecated(note = "Missing required field ui_state")]
            pub fn build(
                self,
                _: ArmyPlacementStart_PropsBuilder_Error_Missing_required_field_ui_state,
            ) -> ArmyPlacementStart_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum ArmyPlacementStart_PropsBuilder_Error_Missing_required_field_ui_info {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            'a,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<'a, ((&'a Signal<UiState>,), ()), G> {
            #[deprecated(note = "Missing required field ui_info")]
            pub fn build(
                self,
                _: ArmyPlacementStart_PropsBuilder_Error_Missing_required_field_ui_info,
            ) -> ArmyPlacementStart_Props<'a, G> {
                ::core::panicking::panic("explicit panic");
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            'a,
            G: Html,
        > ArmyPlacementStart_PropsBuilder<
            'a,
            ((&'a Signal<UiState>,), (&'a Signal<StartArmyPlacementInfo>,)),
            G,
        > {
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> ArmyPlacementStart_Props<'a, G> {
                let (ui_state, ui_info) = self.fields;
                let ui_state = ui_state.0;
                let ui_info = ui_info.0;
                let __phantom0 = ::core::default::Default::default();
                let __phantom1 = ::core::default::Default::default();
                ArmyPlacementStart_Props {
                    ui_state,
                    ui_info,
                    __phantom0,
                    __phantom1,
                }
            }
        }
        #[allow(non_snake_case)]
        pub fn ArmyPlacementStart<'a, G: Html>(
            cx: Scope<'a>,
            __props: ArmyPlacementStart_Props<'a, G>,
        ) -> View<G> {
            let ArmyPlacementStart_Props { ui_state, ui_info, .. } = __props;
            {
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from("running place start"),
                    ]),
                );
                let _ = create_memo(
                    cx,
                    move || {
                        ::gloo_console::externs::log(
                            ::std::boxed::Box::from([
                                ::gloo_console::__macro::JsValue::from("run sub"),
                            ]),
                        );
                        if ui_info
                            .get()
                            .armies_per_player[ui_info.get().current_player as usize]
                            == 0
                        {
                            if ui_info.get().current_player + 1
                                < ui_info.get().num_players
                            {
                                let mut tmp = *ui_info.get();
                                tmp.updated = true;
                                tmp.current_player = tmp.current_player + 1;
                                tmp.is_done = false;
                                ui_info.set(tmp);
                                ui_info.trigger_subscribers();
                                ::gloo_console::externs::log(
                                    ::std::boxed::Box::from([
                                        ::gloo_console::__macro::JsValue::from("triggering subs"),
                                    ]),
                                );
                            } else {
                                ui_state.set(UiState::ARMY_PLACEMENT)
                            }
                        }
                    },
                );
                {
                    #[allow(unused_variables)]
                    let cx: ::sycamore::reactive::BoundedScope = cx;
                    ::sycamore::view::View::new_fragment({
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::h1,
                                    >();
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &::sycamore::generic_node::GenericNode::text_node("Player "),
                                    );
                                    let __view = ::sycamore::view::View::new_dyn(
                                        cx,
                                        move || ::sycamore::view::IntoView::create(
                                            &(ui_info.get().current_player + 1),
                                        ),
                                    );
                                    let __initial = ::sycamore::utils::initial_node(&__el);
                                    let __marker = ::std::option::Option::None;
                                    ::sycamore::utils::render::insert(
                                        cx,
                                        &__el,
                                        __view,
                                        __initial,
                                        __marker,
                                        true,
                                    );
                                    __el
                                }),
                                ::sycamore::view::View::new_node({
                                    let __el = ::sycamore::generic_node::GenericNode::element::<
                                        ::sycamore::web::html::div,
                                    >();
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &::sycamore::generic_node::GenericNode::text_node(
                                            "You still have ",
                                        ),
                                    );
                                    let __view = ::sycamore::view::View::new_dyn(
                                        cx,
                                        move || ::sycamore::view::IntoView::create(
                                            &(ui_info
                                                .get()
                                                .armies_per_player[ui_info.get().current_player as usize]),
                                        ),
                                    );
                                    let __initial = ::sycamore::utils::initial_node(&__el);
                                    let __marker = ::sycamore::generic_node::GenericNode::text_node(
                                        " armies to place",
                                    );
                                    ::sycamore::generic_node::GenericNode::append_child(
                                        &__el,
                                        &__marker,
                                    );
                                    let __marker = ::std::option::Option::Some(&__marker);
                                    ::sycamore::utils::render::insert(
                                        cx,
                                        &__el,
                                        __view,
                                        __initial,
                                        __marker,
                                        true,
                                    );
                                    __el
                                }),
                            ]),
                        )
                    })
                }
            }
        }
    }
    pub mod structs {
        use gloo::console::log;
        use sycamore::prelude::{create_rc_signal, RcSignal};
        use crate::ui::main::UiState;
        use crate::utils::consts::MAX_PLAYERS;
        pub trait UiUpdatable {
            fn update<F>(self, f: F) -> Self
            where
                F: Fn(&mut Self),
                Self: Sized;
        }
        pub struct UiInfo {
            pub ui_state: RcSignal<UiState>,
            pub start_placement: RcSignal<StartArmyPlacementInfo>,
            pub placement: RcSignal<ArmyPlacementInfo>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UiInfo {
            #[inline]
            fn clone(&self) -> UiInfo {
                UiInfo {
                    ui_state: ::core::clone::Clone::clone(&self.ui_state),
                    start_placement: ::core::clone::Clone::clone(&self.start_placement),
                    placement: ::core::clone::Clone::clone(&self.placement),
                }
            }
        }
        impl UiInfo {
            pub fn new() -> UiInfo {
                UiInfo {
                    ui_state: create_rc_signal(UiState::SETUP),
                    start_placement: create_rc_signal(StartArmyPlacementInfo::new()),
                    placement: create_rc_signal(ArmyPlacementInfo::new()),
                }
            }
        }
        pub struct StartArmyPlacementInfo {
            pub is_done: bool,
            pub updated: bool,
            pub current_player: u32,
            pub num_players: u32,
            pub armies_per_player: [u32; MAX_PLAYERS],
        }
        #[automatically_derived]
        impl ::core::marker::Copy for StartArmyPlacementInfo {}
        #[automatically_derived]
        impl ::core::clone::Clone for StartArmyPlacementInfo {
            #[inline]
            fn clone(&self) -> StartArmyPlacementInfo {
                let _: ::core::clone::AssertParamIsClone<bool>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                let _: ::core::clone::AssertParamIsClone<[u32; MAX_PLAYERS]>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for StartArmyPlacementInfo {}
        #[automatically_derived]
        impl ::core::cmp::Eq for StartArmyPlacementInfo {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<[u32; MAX_PLAYERS]>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for StartArmyPlacementInfo {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StartArmyPlacementInfo {
            #[inline]
            fn eq(&self, other: &StartArmyPlacementInfo) -> bool {
                self.is_done == other.is_done && self.updated == other.updated
                    && self.current_player == other.current_player
                    && self.num_players == other.num_players
                    && self.armies_per_player == other.armies_per_player
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StartArmyPlacementInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "StartArmyPlacementInfo",
                    "is_done",
                    &self.is_done,
                    "updated",
                    &self.updated,
                    "current_player",
                    &self.current_player,
                    "num_players",
                    &self.num_players,
                    "armies_per_player",
                    &&self.armies_per_player,
                )
            }
        }
        impl UiUpdatable for StartArmyPlacementInfo {
            fn update<F>(self, f: F) -> Self
            where
                F: Fn(&mut Self),
                Self: Sized,
            {
                let mut tmp = self.clone();
                f(&mut tmp);
                tmp.updated = true;
                ::gloo_console::externs::log(
                    ::std::boxed::Box::from([
                        ::gloo_console::__macro::JsValue::from({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "updating start placement info {0:?}",
                                    tmp.clone(),
                                ),
                            );
                            res
                        }),
                    ]),
                );
                return tmp;
            }
        }
        impl StartArmyPlacementInfo {
            pub fn new() -> StartArmyPlacementInfo {
                StartArmyPlacementInfo {
                    is_done: false,
                    updated: false,
                    current_player: 0,
                    num_players: 0,
                    armies_per_player: [0; MAX_PLAYERS],
                }
            }
        }
        pub struct ArmyPlacementInfo {
            pub army_count: u32,
            pub is_done: bool,
            pub updated: bool,
            pub current_player: u32,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ArmyPlacementInfo {}
        #[automatically_derived]
        impl ::core::clone::Clone for ArmyPlacementInfo {
            #[inline]
            fn clone(&self) -> ArmyPlacementInfo {
                let _: ::core::clone::AssertParamIsClone<u32>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for ArmyPlacementInfo {}
        #[automatically_derived]
        impl ::core::cmp::Eq for ArmyPlacementInfo {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ArmyPlacementInfo {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ArmyPlacementInfo {
            #[inline]
            fn eq(&self, other: &ArmyPlacementInfo) -> bool {
                self.army_count == other.army_count && self.is_done == other.is_done
                    && self.updated == other.updated
                    && self.current_player == other.current_player
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ArmyPlacementInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ArmyPlacementInfo",
                    "army_count",
                    &self.army_count,
                    "is_done",
                    &self.is_done,
                    "updated",
                    &self.updated,
                    "current_player",
                    &&self.current_player,
                )
            }
        }
        impl UiUpdatable for ArmyPlacementInfo {
            fn update<F>(self, f: F) -> Self
            where
                F: Fn(&mut Self),
                Self: Sized,
            {
                let mut tmp = self.clone();
                f(&mut tmp);
                tmp.updated = true;
                return tmp;
            }
        }
        impl ArmyPlacementInfo {
            pub fn new() -> ArmyPlacementInfo {
                ArmyPlacementInfo {
                    army_count: 0,
                    is_done: false,
                    updated: false,
                    current_player: 0,
                }
            }
        }
    }
}
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use crate::canvas::get_map_lookup_data;
use crate::game::Game;
use sycamore;
use sycamore::prelude::Scope;
use crate::element_getters::get_element_by_id;
use crate::ui::main::UiMainProps;
use gloo::console::log as console_log;
#[allow(dead_code)]
fn setup() {
    console_error_panic_hook::set_once();
    tracing_wasm::set_as_global_default();
    let mut prov_coords: Vec<[i32; 2]> = Vec::new();
    prov_coords.push([388, 204]);
    ::gloo_console::externs::log(
        ::std::boxed::Box::from([::gloo_console::__macro::JsValue::from("starting")]),
    );
    let game = Game::new(get_map_lookup_data(50));
    let refc_game = Rc::from(RefCell::from(game));
    canvas::ui_init_canvas(refc_game.clone());
    let cloj = |cx: Scope| { ui::main::UiSide(cx, UiMainProps { game_ref: refc_game }) };
    sycamore::render_to(cloj, &get_element_by_id("main"));
}
#[automatically_derived]
const _: () = {
    pub unsafe extern "C" fn __wasm_bindgen_generated_setup() -> <() as wasm_bindgen::convert::ReturnWasmAbi>::Abi {
        const _ASSERT: fn() = || -> <() as wasm_bindgen::convert::ReturnWasmAbi>::Abi {
            loop {}
        };
        let _ret = {
            let _ret = setup();
            <() as wasm_bindgen::__rt::Start>::start(_ret)
        };
        <() as wasm_bindgen::convert::ReturnWasmAbi>::return_abi(_ret)
    }
};
